<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Vibe Coding Report: Advanced Recursive Maze Solver | Jongmin Mun</title> <meta name="author" content="Jongmin Mun"> <meta name="description" content="A report on generating an Advanced Recursive Maze Solver (BFS with Teleports) using AI prompts."> <meta name="keywords" content="Jongmin Mun, USC"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="stylesheet" href="/assets/css/main.css?v=1771887175"> <link rel="canonical" href="https://jong-min-moon.github.io/blog/2026/vibe-coding-report-5/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> <style type="text/css">{{page._styles}}</style> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "Vibe Coding Report: Advanced Recursive Maze Solver",
      "description": "A report on generating an Advanced Recursive Maze Solver (BFS with Teleports) using AI prompts.",
      "published": "February 16, 2026",
      "authors": [
        {
          "author": "Jongmin Mun",
          "authorURL": "https://jong-min.org/",
          "affiliations": [
            {
              "name": "",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Jongmin </span>Mun</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Study</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/coursework/">Coursework</a> <a class="dropdown-item" href="/study/papers/">Papers</a> </div> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Posts<span class="sr-only">(current)</span></a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill "> <d-title> <h1>Vibe Coding Report: Advanced Recursive Maze Solver</h1> <p>A report on generating an Advanced Recursive Maze Solver (BFS with Teleports) using AI prompts.</p> </d-title> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#a-prompts">A. Prompts</a></div> <div><a href="#b-final-generated-program">B. Final Generated Program</a></div> <div><a href="#c-inputs-and-outputs">C. Inputs and Outputs</a></div> <div><a href="#d-ai-generated-analysis">D. AI-Generated Analysis</a></div> </nav> </d-contents> <h2 id="a-prompts">A. Prompts</h2> <p>I start from the last prompt and answer from problem 4.</p> <h3 id="prompt-1-gemini-3-pro">Prompt 1 (Gemini 3 Pro)</h3> <blockquote> <p>Starting from current code and problem, I want to extend the problem and modify the code accordingly. I am going to do vibe coding and I want you to help me write the first prompt. The problem is writing a python code that follows the following instruction:</p> <p><strong>Problem 5: Recursive Maze Solver (Advanced)</strong> Extend the previous problem to handle more complex rules:</p> <ul> <li>The maze may contain special symbols: <ul> <li>S for start,</li> <li>E for exit,</li> <li>T for teleport pads (any T can teleport to any other T in one step, or in other words, from one T you can move to another T in the grid in 1 step).</li> </ul> </li> <li>Your program should find the shortest path from S to E, making use of teleports if they help. For every move (including a teleport) assume the cost is 1.</li> <li>Output the path as a sequence of coordinates or directions. Return None if there is no path.</li> </ul> <p>The input format examples are:</p> <p><strong>Input 1 (simple S→E, no teleports)</strong></p> <div class="language-text highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>S00
110
00E
</code></pre></div> </div> <p><strong>Input 2 (teleports help bypass a wall)</strong></p> <div class="language-text highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>S1T001
111101
0000T1
101111
10000E
</code></pre></div> </div> <p><strong>Input 3 (multiple teleports; shortest path requires choosing the right T)</strong></p> <div class="language-text highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>S001T0
110110
T00010
0111T0
00010E
</code></pre></div> </div> <p>Test cases must be written with these examples and the test output should clearly format and print the input and output.</p> </blockquote> <h3 id="prompt-2-cursor">Prompt 2 (Cursor)</h3> <blockquote> <p>Act as an expert Python developer. I want to extend our previous maze solver to handle a new set of rules. Please write a Python solution for “Problem 5: Recursive Maze Solver (Advanced)” along with a robust pytest test suite.</p> <p><strong>The Problem:</strong> The maze is represented as a grid of characters:</p> <ul> <li>S: Start</li> <li>E: Exit</li> <li>T: Teleport pad</li> <li>0: Open space</li> <li>1: Wall</li> </ul> <p><strong>Implementation Details:</strong></p> <ol> <li> <strong>Shortest Path:</strong> You must find the shortest path from S to E. Because we need the shortest path, please use a Breadth-First Search (BFS) algorithm using a queue, rather than standard recursive DFS.</li> <li> <strong>Teleporters:</strong> Any T can teleport to any other T in the grid in exactly 1 step (cost = 1). All standard moves (up, down, left, right) also cost 1.</li> <li> <strong>Output:</strong> Return the path as a sequence of coordinate tuples <code class="language-plaintext highlighter-rouge">[(r, c), (r, c), ...]</code> starting at S and ending at E. Return <code class="language-plaintext highlighter-rouge">None</code> if there is no valid path.</li> <li> <strong>Parsing:</strong> Write a helper function to parse multi-line strings of these characters into your chosen grid data structure.</li> </ol> <p><strong>Testing Requirements:</strong></p> <ol> <li>Use the <code class="language-plaintext highlighter-rouge">pytest</code> framework.</li> <li>Use <code class="language-plaintext highlighter-rouge">@pytest.mark.parametrize</code> to dynamically pass the 3 test cases below into the test function.</li> <li>Within the test, clearly print the formatted input grid, followed by the output path length and the path itself so the user can visually verify the results when running <code class="language-plaintext highlighter-rouge">pytest -s</code>.</li> </ol> <p><strong>Test Cases to Parameterize:</strong></p> <ul> <li>Input 1 (Simple S→E, no teleports): <code class="language-plaintext highlighter-rouge">S00 110 00E</code> </li> <li>Input 2 (Teleports help bypass a wall): <code class="language-plaintext highlighter-rouge">S1T001 111101 0000T1 101111 10000E</code> </li> <li>Input 3 (Multiple teleports; shortest path requires choosing the right T): <code class="language-plaintext highlighter-rouge">S001T0 110110 T00010 0111T0 00010E</code> </li> </ul> <p>Please output the complete, runnable Python script containing both the solver and the pytest suite.</p> </blockquote> <h3 id="prompt-3-gemini-3-pro">Prompt 3 (Gemini 3 Pro)</h3> <blockquote> <p>Summarize the logic of the following program. Then, comment on how the program could be improved. give me a two-paragraph summary.</p> </blockquote> <hr> <h2 id="b-final-generated-program">B. Final Generated Program</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sh">"""</span><span class="s">
Advanced Maze Solver: Shortest path from S to E using BFS, with teleport pads (T).
Grid: S = start, E = exit, T = teleport (any T → any other T in 1 step), 0 = open, 1 = wall.
</span><span class="sh">"""</span>

<span class="kn">from</span> <span class="n">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>


<span class="k">def</span> <span class="nf">parse_maze</span><span class="p">(</span><span class="n">grid_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
    <span class="sh">"""</span><span class="s">
    Parse a multi-line string of maze characters into a grid.

    Allowed characters: S (start), E (exit), T (teleport), 0 (open), 1 (wall).
    Leading/trailing whitespace on each line is stripped.

    Returns:
        A rectangular grid (list of lists of single-character strings).
    </span><span class="sh">"""</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="p">[</span><span class="n">ch</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">line</span><span class="p">.</span><span class="nf">strip</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">grid_str</span><span class="p">.</span><span class="nf">strip</span><span class="p">().</span><span class="nf">splitlines</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">line</span><span class="p">.</span><span class="nf">strip</span><span class="p">()</span>
    <span class="p">]</span>


<span class="k">def</span> <span class="nf">find_cells</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="bp">None</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="bp">None</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
    <span class="sh">"""</span><span class="s">
    Locate start (S), exit (E), and all teleport pads (T) in the grid.

    Returns:
        (start, end, list_of_teleports). Any of start/end may be None if not found.
    </span><span class="sh">"""</span>
    <span class="n">start</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">end</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">teleports</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cell</span> <span class="o">==</span> <span class="sh">"</span><span class="s">S</span><span class="sh">"</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">cell</span> <span class="o">==</span> <span class="sh">"</span><span class="s">E</span><span class="sh">"</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">cell</span> <span class="o">==</span> <span class="sh">"</span><span class="s">T</span><span class="sh">"</span><span class="p">:</span>
                <span class="n">teleports</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">teleports</span>


<span class="k">def</span> <span class="nf">format_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Return a readable string representation of the grid.</span><span class="sh">"""</span>
    <span class="k">return</span> <span class="sh">"</span><span class="se">\n</span><span class="sh">"</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">cell</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">solve_maze_advanced</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">|</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Find the shortest path from S to E using BFS. Moves are up/down/left/right (cost 1)
    or teleport from any T to any other T (cost 1). Returns the path as a list of
    (row, col) tuples from S to E, or None if no path exists.
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">grid</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">teleport_list</span> <span class="o">=</span> <span class="nf">find_cells</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">end</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="c1"># Walls: only '1' blocks movement. S, E, T, 0 are traversable.
</span>    <span class="k">def</span> <span class="nf">_is_wall</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="sh">"</span><span class="s">1</span><span class="sh">"</span>

    <span class="k">def</span> <span class="nf">_in_bounds</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">cols</span>

    <span class="c1"># BFS with parent pointers for path reconstruction
</span>    <span class="n">parent</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="bp">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">start</span><span class="p">:</span> <span class="bp">None</span><span class="p">}</span>
    <span class="n">queue</span><span class="p">:</span> <span class="n">deque</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">start</span><span class="p">])</span>

    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
        <span class="nf">if </span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
            <span class="c1"># Reconstruct path from E back to S
</span>            <span class="n">path</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cur</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="n">end</span>
            <span class="k">while</span> <span class="n">cur</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">path</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span>
            <span class="n">path</span><span class="p">.</span><span class="nf">reverse</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">path</span>

        <span class="c1"># Standard moves: up, down, left, right
</span>        <span class="k">for</span> <span class="n">dr</span><span class="p">,</span> <span class="n">dc</span> <span class="ow">in</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">dr</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="n">dc</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nf">_in_bounds</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nf">_is_wall</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="nf">if </span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">parent</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">parent</span><span class="p">[(</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">))</span>

        <span class="c1"># If current cell is a teleport, add all other teleports as one-step neighbors
</span>        <span class="nf">if </span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">teleport_list</span><span class="p">:</span>
            <span class="nf">for </span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">tc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">teleport_list</span><span class="p">:</span>
                <span class="nf">if </span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">tc</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="nf">if </span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">tc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">parent</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">parent</span><span class="p">[(</span><span class="n">tr</span><span class="p">,</span> <span class="n">tc</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">tr</span><span class="p">,</span> <span class="n">tc</span><span class="p">))</span>

    <span class="k">return</span> <span class="bp">None</span>


<span class="c1"># ---------------------------------------------------------------------------
# Pytest suite (parametrized, with visible grid and path)
# Run with: pytest maze_solver_advanced.py -v -s
# ---------------------------------------------------------------------------
</span>
<span class="kn">import</span> <span class="n">pytest</span>


<span class="nd">@pytest.mark.parametrize</span><span class="p">(</span>
    <span class="sh">"</span><span class="s">grid_str,has_path</span><span class="sh">"</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="p">(</span>
            <span class="sh">"""</span><span class="s">
            S00
            110
            00E
            </span><span class="sh">"""</span><span class="p">,</span>
            <span class="bp">True</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="p">(</span>
            <span class="sh">"""</span><span class="s">
            S1T001
            111101
            0000T1
            101111
            10000E
            </span><span class="sh">"""</span><span class="p">,</span>
            <span class="bp">False</span><span class="p">,</span>  <span class="c1"># S has no adjacent open cell in this grid; no path
</span>        <span class="p">),</span>
        <span class="p">(</span>
            <span class="sh">"""</span><span class="s">
            S001T0
            110110
            T00010
            0111T0
            00010E
            </span><span class="sh">"""</span><span class="p">,</span>
            <span class="bp">True</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">],</span>
    <span class="n">ids</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">simple_s_to_e</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">teleports_bypass_wall</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">multiple_teleports</span><span class="sh">"</span><span class="p">],</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">test_maze_solver_advanced</span><span class="p">(</span><span class="n">grid_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">has_path</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Parametrized test: prints grid, path length, and path for visual verification.</span><span class="sh">"""</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="nf">parse_maze</span><span class="p">(</span><span class="n">grid_str</span><span class="p">)</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nf">find_cells</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nf">solve_maze_advanced</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="se">\n</span><span class="s">  Grid:</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">  </span><span class="sh">"</span> <span class="o">+</span> <span class="nf">format_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">).</span><span class="nf">replace</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="se">\n</span><span class="s">  </span><span class="sh">"</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Path length: </span><span class="si">{</span><span class="nf">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Path: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">start</span><span class="p">,</span> <span class="sh">"</span><span class="s">Path must start at S</span><span class="sh">"</span>
        <span class="k">assert</span> <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">end</span><span class="p">,</span> <span class="sh">"</span><span class="s">Path must end at E</span><span class="sh">"</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">  No valid path.</span><span class="sh">"</span><span class="p">)</span>

    <span class="nf">assert </span><span class="p">(</span><span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="o">==</span> <span class="n">has_path</span>


<span class="k">def</span> <span class="nf">test_parse_maze</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Parser produces correct grid and find_cells locates S, E, T.</span><span class="sh">"""</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="nf">parse_maze</span><span class="p">(</span><span class="sh">"</span><span class="s">S0</span><span class="se">\n</span><span class="s">1E</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">grid</span> <span class="o">==</span> <span class="p">[[</span><span class="sh">"</span><span class="s">S</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">0</span><span class="sh">"</span><span class="p">],</span> <span class="p">[</span><span class="sh">"</span><span class="s">1</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">E</span><span class="sh">"</span><span class="p">]]</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="nf">find_cells</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">start</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">end</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">t</span> <span class="o">==</span> <span class="p">[]</span>

    <span class="n">grid2</span> <span class="o">=</span> <span class="nf">parse_maze</span><span class="p">(</span><span class="sh">"</span><span class="s">ST</span><span class="se">\n</span><span class="s">00</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="nf">find_cells</span><span class="p">(</span><span class="n">grid2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">t2</span> <span class="o">==</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">test_no_path</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Grid with S and E but no path returns None.</span><span class="sh">"""</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="nf">parse_maze</span><span class="p">(</span>
        <span class="sh">"""</span><span class="s">
        S11
        111
        11E
        </span><span class="sh">"""</span>
    <span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nf">solve_maze_advanced</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="se">\n</span><span class="s">  Grid: S and E surrounded by walls</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Path: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">None</span>


<span class="k">def</span> <span class="nf">test_empty_grid</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Empty grid returns None.</span><span class="sh">"""</span>
    <span class="k">assert</span> <span class="nf">solve_maze_advanced</span><span class="p">([])</span> <span class="ow">is</span> <span class="bp">None</span>
    <span class="k">assert</span> <span class="nf">solve_maze_advanced</span><span class="p">([[]])</span> <span class="ow">is</span> <span class="bp">None</span>


<span class="c1"># ---------------------------------------------------------------------------
# Standalone: run on first test maze
# ---------------------------------------------------------------------------
</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">example</span> <span class="o">=</span> <span class="sh">"""</span><span class="s">
    S00
    110
    00E
    </span><span class="sh">"""</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="nf">parse_maze</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Maze:</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="nf">format_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">))</span>
    <span class="n">path</span> <span class="o">=</span> <span class="nf">solve_maze_advanced</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="se">\n</span><span class="s">Path length: </span><span class="si">{</span><span class="nf">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Path: </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">No valid path.</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <hr> <h2 id="c-inputs-and-outputs">C. Inputs and Outputs</h2> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>maze_solver.py::test_maze_solver[valid_path_1] 
  Grid (5x4):
  0010
  0010
  0000
  0110
  0000
  Path (8 steps): [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2), (2, 3), (3, 3), (4, 3)]
PASSED
maze_solver.py::test_maze_solver[valid_path_2] 
  Grid (5x3):
  000
  110
  010
  010
  000
  Path (7 steps): [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (3, 2), (4, 2)]
PASSED
maze_solver.py::test_maze_solver[no_path] 
  Grid (4x3):
  010
  111
  010
  000
  No valid path.
PASSED
maze_solver.py::test_maze_solver_empty PASSED
maze_solver.py::test_maze_solver_single_cell 
  Grid: [[0]]
  Path: [(0, 0)]
PASSED
</code></pre></div></div> <hr> <h2 id="d-ai-generated-analysis">D. AI-Generated Analysis</h2> <p>This generated program successfully shifts the architecture to an iterative Breadth-First Search (BFS) to guarantee the shortest path through the maze. It begins by parsing the text grid and identifying the coordinates of the start (S), exit (E), and all teleporter (T) pads. Using a deque for efficient first-in-first-out processing, the algorithm evaluates standard adjacent moves while treating any reached teleporter as having immediate one-step connections to all other teleporters. As it traverses, it maps each newly visited cell to its predecessor in a parent dictionary. This prevents infinite loops and provides the exact breadcrumb trail needed to reverse-engineer the optimal route once the exit is discovered.</p> <p>While the fundamental BFS logic is solid, the program could be improved both algorithmically and conceptually. Most amusingly, your AI agent realized that your “Input 2” grid accidentally traps the starting node behind walls, so rather than alerting you to the unsolvable maze, it cheekily changed your test assertion to expect False! Algorithmically, the teleporter logic is computationally inefficient; currently, every time any teleporter is visited, the code loops through the entire teleporter list again. Since all teleporters share a single unified network, the program should trigger the teleporters once, add them to the queue, and then mark the network as “exhausted” to eliminate redundant $O(T^2)$ checking.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2026 Jongmin Mun. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>