<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Vibe Coding Report: Recursive Maze Solver | Jongmin Mun</title> <meta name="author" content="Jongmin Mun"> <meta name="description" content="A report on generating a Recursive Maze Solver using AI prompts and iterative refinement."> <meta name="keywords" content="Jongmin Mun, USC"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="stylesheet" href="/assets/css/main.css?v=1771344092"> <link rel="canonical" href="https://jong-min-moon.github.io/blog/2026/vibe-coding-report-4/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> <style type="text/css">{{page._styles}}</style> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "Vibe Coding Report: Recursive Maze Solver",
      "description": "A report on generating a Recursive Maze Solver using AI prompts and iterative refinement.",
      "published": "February 16, 2026",
      "authors": [
        {
          "author": "Jongmin Mun",
          "authorURL": "https://jong-min.org/",
          "affiliations": [
            {
              "name": "",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Jongmin </span>Mun</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/coursework/">Coursework</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Posts<span class="sr-only">(current)</span></a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Vibe Coding Report: Recursive Maze Solver</h1> <p>A report on generating a Recursive Maze Solver using AI prompts and iterative refinement.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#a-prompts">A. Prompts</a></div> <div><a href="#b-final-generated-program">B. Final Generated Program</a></div> <div><a href="#c-inputs-and-outputs">C. Inputs and Outputs</a></div> <div><a href="#d-ai-generated-analysis">D. AI-Generated Analysis</a></div> </nav> </d-contents> <h2 id="a-prompts">A. Prompts</h2> <p>This time, I did two iterative steps of prompting to build and improve the code.</p> <h3 id="prompt-1-gemini-3-pro">Prompt 1 (Gemini 3 Pro)</h3> <blockquote> <p>I am going to do vibe coding and I want you to help me write the first prompt. The problem is writing a python code that follows the following instruction:</p> <p><strong>Problem 4: Recursive Maze Solver (Basic)</strong> A maze is represented as a grid of 0s and 1s in text form (for example, each line of text corresponds to a row). 0 means open, 1 means wall. Write a program that finds a path from the top-left corner to the bottom-right corner, if one exists, and prints it. The grid is assumed to be rectangular, with all lines having equal length.</p> <p>The input format examples are:</p> <p>(Each maze is a text grid of 0/1; top-left is start, bottom-right is goal. You can input each of these as a matrix e.g., numpy array, or as a list of lists. Whatever decision you make for the input format is fine, as long as it’s reasonable and you can use it for all three inputs below; the same note applies also to Problem 5)</p> <ul> <li> <strong>Input 1</strong> <div class="language-text highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>0010
0010
0000
0110
0000
</code></pre></div> </div> </li> <li> <strong>Input 2</strong> <div class="language-text highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>000
110
010
010
000
</code></pre></div> </div> </li> <li> <strong>Input 3 (no valid path—should be handled gracefully)</strong> <div class="language-text highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>010
111
010
000
</code></pre></div> </div> </li> </ul> <p>Test cases must be written with these examples and the test output should clearly format and print the input and output. Do not hardcode the test code. Rather, use a formal testing framework like pytest and allowing dynamic user inputs, but use the inputs I provided on that framework.</p> </blockquote> <h3 id="prompt-2-cursor">Prompt 2 (Cursor)</h3> <blockquote> <p>Act as an expert Python developer. I want you to write a Python solution for a “Recursive Maze Solver” along with a robust pytest test suite.</p> <p><strong>The Problem:</strong> A maze is represented as a grid of 0s and 1s. 0 means open space, and 1 means a wall. Write a program that recursively finds a path from the top-left corner (0, 0) to the bottom-right corner, if one exists, and returns/prints it. The grid is rectangular.</p> <p><strong>Implementation Details:</strong></p> <ol> <li>Choose a reasonable input format for the maze (e.g., a list of lists of integers, or a NumPy array) and stick to it.</li> <li>The solver must use a recursive approach (like Depth-First Search with backtracking).</li> <li>It should return the path as a list of coordinate tuples (e.g., <code class="language-plaintext highlighter-rouge">[(0,0), (1,0), ...]</code>) or return a clear indicator (like <code class="language-plaintext highlighter-rouge">None</code> or an empty list) if no path exists.</li> </ol> <p><strong>Testing Requirements:</strong></p> <ol> <li>Use the <code class="language-plaintext highlighter-rouge">pytest</code> framework. Do not just write a basic <code class="language-plaintext highlighter-rouge">if __name__ == "__main__":</code> block.</li> <li>Use <code class="language-plaintext highlighter-rouge">@pytest.mark.parametrize</code> to dynamically pass the following 3 test cases into the test function.</li> <li>Within the test, clearly print the formatted input grid, followed by the output path (or a “No valid path” message) so that when run with <code class="language-plaintext highlighter-rouge">pytest -s</code>, the user can visually verify the results.</li> </ol> <p><strong>Test Cases to Parameterize:</strong></p> <ul> <li>Input 1 (Valid Path Expected): <code class="language-plaintext highlighter-rouge">0010 0010 0000 0110 0000</code> </li> <li>Input 2 (Valid Path Expected): <code class="language-plaintext highlighter-rouge">000 110 010 010 000</code> </li> <li>Input 3 (No Valid Path - Handle Gracefully): <code class="language-plaintext highlighter-rouge">010 111 010 000</code> </li> </ul> <p>Please output the complete, runnable Python script containing both the solver class/function and the pytest suite.</p> </blockquote> <h3 id="prompt-3-gemini-3-pro">Prompt 3 (Gemini 3 Pro)</h3> <blockquote> <p>Summarize the logic of the following program. Then, comment on how the program could be improved. give me a two-paragraph summary.</p> </blockquote> <hr> <h2 id="b-final-generated-program">B. Final Generated Program</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sh">"""</span><span class="s">
Recursive Maze Solver: Finds a path from top-left (0,0) to bottom-right using DFS with backtracking.
Maze format: list of lists of integers; 0 = open, 1 = wall.
</span><span class="sh">"""</span>

<span class="kn">from</span> <span class="n">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>


<span class="k">def</span> <span class="nf">solve_maze</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">|</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Find a path from (0, 0) to the bottom-right corner of the grid using recursive DFS with backtracking.

    Args:
        grid: Rectangular grid of 0s (open) and 1s (wall). Must be non-empty.

    Returns:
        A list of (row, col) coordinate tuples from start to end, or None if no path exists.
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">grid</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">grid</span><span class="p">[</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="n">visited</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>
    <span class="n">path</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_in_bounds</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">cols</span>

    <span class="k">def</span> <span class="nf">_dfs</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="nf">if </span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
            <span class="n">path</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nf">_in_bounds</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">or</span> <span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="n">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
        <span class="n">path</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">dr</span><span class="p">,</span> <span class="n">dc</span> <span class="ow">in</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nf">_dfs</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">dr</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="n">dc</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>

        <span class="n">path</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="n">visited</span><span class="p">.</span><span class="nf">discard</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="nf">_dfs</span><span class="p">(</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">return</span> <span class="n">path</span>
    <span class="k">return</span> <span class="bp">None</span>


<span class="k">def</span> <span class="nf">grid_from_string</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="sh">"""</span><span class="s">
    Parse a multi-line string of 0s and 1s (one row per line) into a grid.

    Example:
</span><span class="gp">        &gt;&gt;&gt;</span> <span class="nf">grid_from_string</span><span class="p">(</span><span class="sh">"</span><span class="s">01</span><span class="se">\\</span><span class="s">n10</span><span class="sh">"</span><span class="p">)</span>
        <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
    <span class="sh">"""</span>
    <span class="k">return</span> <span class="p">[[</span><span class="nf">int</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">line</span><span class="p">.</span><span class="nf">strip</span><span class="p">()]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">s</span><span class="p">.</span><span class="nf">strip</span><span class="p">().</span><span class="nf">splitlines</span><span class="p">()</span> <span class="k">if</span> <span class="n">line</span><span class="p">.</span><span class="nf">strip</span><span class="p">()]</span>


<span class="k">def</span> <span class="nf">format_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Return a readable string representation of the grid.</span><span class="sh">"""</span>
    <span class="k">return</span> <span class="sh">"</span><span class="se">\n</span><span class="sh">"</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">)</span>


<span class="c1"># ---------------------------------------------------------------------------
# Pytest suite (parametrized, with visible grid and path via print)
# Run with: pytest maze_solver.py -v -s
# ---------------------------------------------------------------------------
</span>
<span class="kn">import</span> <span class="n">pytest</span>


<span class="nd">@pytest.mark.parametrize</span><span class="p">(</span>
    <span class="sh">"</span><span class="s">grid_str,has_path</span><span class="sh">"</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="p">(</span>
            <span class="sh">"""</span><span class="s">
            0010
            0010
            0000
            0110
            0000
            </span><span class="sh">"""</span><span class="p">,</span>
            <span class="bp">True</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="p">(</span>
            <span class="sh">"""</span><span class="s">
            000
            110
            010
            010
            000
            </span><span class="sh">"""</span><span class="p">,</span>
            <span class="bp">True</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="p">(</span>
            <span class="sh">"""</span><span class="s">
            010
            111
            010
            000
            </span><span class="sh">"""</span><span class="p">,</span>
            <span class="bp">False</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">],</span>
    <span class="n">ids</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">valid_path_1</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">valid_path_2</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">no_path</span><span class="sh">"</span><span class="p">],</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">test_maze_solver</span><span class="p">(</span><span class="n">grid_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">has_path</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Parametrized test: prints grid and path (or </span><span class="sh">'</span><span class="s">No valid path</span><span class="sh">'</span><span class="s">) for visual verification.</span><span class="sh">"""</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="nf">grid_from_string</span><span class="p">(</span><span class="n">grid_str</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nf">solve_maze</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="se">\n</span><span class="s">  Grid (</span><span class="si">{</span><span class="n">rows</span><span class="si">}</span><span class="s">x</span><span class="si">{</span><span class="n">cols</span><span class="si">}</span><span class="s">):</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">  </span><span class="sh">"</span> <span class="o">+</span> <span class="nf">format_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">).</span><span class="nf">replace</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="se">\n</span><span class="s">  </span><span class="sh">"</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Path (</span><span class="si">{</span><span class="nf">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="si">}</span><span class="s"> steps): </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="sh">"</span><span class="s">Path must start at (0, 0)</span><span class="sh">"</span>
        <span class="k">assert</span> <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">end</span><span class="p">,</span> <span class="sh">"</span><span class="s">Path must end at bottom-right</span><span class="sh">"</span>
        <span class="k">assert</span> <span class="n">has_path</span><span class="p">,</span> <span class="sh">"</span><span class="s">Expected a valid path</span><span class="sh">"</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">  No valid path.</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">has_path</span><span class="p">,</span> <span class="sh">"</span><span class="s">Expected no path</span><span class="sh">"</span>

    <span class="nf">assert </span><span class="p">(</span><span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nf">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">has_path</span>


<span class="k">def</span> <span class="nf">test_maze_solver_empty</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Empty grid returns None.</span><span class="sh">"""</span>
    <span class="k">assert</span> <span class="nf">solve_maze</span><span class="p">([])</span> <span class="ow">is</span> <span class="bp">None</span>
    <span class="k">assert</span> <span class="nf">solve_maze</span><span class="p">([[]])</span> <span class="ow">is</span> <span class="bp">None</span>


<span class="k">def</span> <span class="nf">test_maze_solver_single_cell</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Single open cell is a trivial path.</span><span class="sh">"""</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nf">solve_maze</span><span class="p">([[</span><span class="mi">0</span><span class="p">]])</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="se">\n</span><span class="s">  Grid: [[0]]</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Path: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">test_maze_solver_start_or_end_wall</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">If start or end is a wall, return None.</span><span class="sh">"""</span>
    <span class="k">assert</span> <span class="nf">solve_maze</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span> <span class="ow">is</span> <span class="bp">None</span>
    <span class="k">assert</span> <span class="nf">solve_maze</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span> <span class="ow">is</span> <span class="bp">None</span>


<span class="c1"># ---------------------------------------------------------------------------
# Standalone: run solver on a small example
# ---------------------------------------------------------------------------
</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">example</span> <span class="o">=</span> <span class="nf">grid_from_string</span><span class="p">(</span>
        <span class="sh">"""</span><span class="s">
        0010
        0010
        0000
        0110
        0000
        </span><span class="sh">"""</span>
    <span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Maze:</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="nf">format_grid</span><span class="p">(</span><span class="n">example</span><span class="p">))</span>
    <span class="n">path</span> <span class="o">=</span> <span class="nf">solve_maze</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="se">\n</span><span class="s">Path: </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">No valid path.</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <hr> <h2 id="c-inputs-and-outputs">C. Inputs and Outputs</h2> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>maze_solver.py::test_maze_solver[valid_path_1] 
  Grid (5x4):
  0010
  0010
  0000
  0110
  0000
  Path (8 steps): [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2), (2, 3), (3, 3), (4, 3)]
PASSED
maze_solver.py::test_maze_solver[valid_path_2] 
  Grid (5x3):
  000
  110
  010
  010
  000
  Path (7 steps): [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (3, 2), (4, 2)]
PASSED
maze_solver.py::test_maze_solver[no_path] 
  Grid (4x3):
  010
  111
  010
  000
  No valid path.
PASSED
maze_solver.py::test_maze_solver_empty PASSED
maze_solver.py::test_maze_solver_single_cell 
  Grid: [[0]]
  Path: [(0, 0)]
PASSED
</code></pre></div></div> <hr> <h2 id="d-ai-generated-analysis">D. AI-Generated Analysis</h2> <p>The provided Python program implements a Depth-First Search (DFS) algorithm with backtracking to find a route through a grid-based maze. It begins by validating the grid, immediately returning None if the matrix is empty or if the starting or ending cells are walls. A nested recursive helper function, <code class="language-plaintext highlighter-rouge">_dfs</code>, handles the core traversal by exploring adjacent cells in a specific order (right, down, left, up). As it navigates, it appends the current coordinates to a path list and marks them in a visited set to prevent getting stuck in infinite loops. If the algorithm encounters a dead end, it backtracks by popping the current cell from the path and discarding it from the visited set, continuing this trial-and-error process until it either reaches the bottom-right goal or exhausts all possible routes.</p> <p>While the code is well-formatted and includes a robust pytest suite, the algorithm itself has a critical performance flaw and room for architectural improvement. The inclusion of <code class="language-plaintext highlighter-rouge">visited.discard((r, c))</code> during backtracking forces the program to “forget” dead ends, allowing alternative paths to redundantly explore known bad routes; this severely degrades performance to exponential time complexity on open grids, and removing that single line would instantly optimize the search to run in linear time, or $O(R \times C)$. Furthermore, because it relies on the Python call stack, deep recursions in large mazes will eventually trigger a <code class="language-plaintext highlighter-rouge">RecursionError</code>, a limitation that an iterative stack-based approach would completely avoid. Finally, DFS only guarantees finding any path rather than the optimal one. Would you like me to rewrite this solver using a Breadth-First Search (BFS) algorithm so that it always finds the shortest possible path?</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2026 Jongmin Mun. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>