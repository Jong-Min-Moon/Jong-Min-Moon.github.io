<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://jong-min-moon.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://jong-min-moon.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2026-02-20T08:40:48+00:00</updated><id>https://jong-min-moon.github.io/feed.xml</id><title type="html">blank</title><subtitle>Personal website of Jongmin Mun. </subtitle><entry><title type="html">Paper review: Improving randomized controlled trial analysis via data-adaptive borrowing</title><link href="https://jong-min-moon.github.io/blog/2026/data-adaptive-borrowing/" rel="alternate" type="text/html" title="Paper review: Improving randomized controlled trial analysis via data-adaptive borrowing"/><published>2026-02-20T00:00:00+00:00</published><updated>2026-02-20T00:00:00+00:00</updated><id>https://jong-min-moon.github.io/blog/2026/data-adaptive-borrowing</id><content type="html" xml:base="https://jong-min-moon.github.io/blog/2026/data-adaptive-borrowing/"><![CDATA[<h2 id="core-assumptions">Core Assumptions</h2> <p><strong>Assumption 2 (External control compatibility).</strong> Suppose that (i) $E{Y(0) \mid X = x, R = 0} = E{Y (0) \mid X = x, R = 1}$ and…</p> <h2 id="the-detection-mechanism">The Detection Mechanism</h2> <p>The adaptive lasso penalty detects incomparable external controls by recasting the challenge of identifying compatible subjects as a model selection problem based on individual bias. Here is how the detection mechanism works:</p> <ul> <li><strong>Defining the Bias Parameter:</strong> For each external control subject, a specific bias parameter ($b_{i,0}$) is introduced. This parameter measures the difference in the expected outcome between the external control subject and a concurrent trial control subject, given their baseline covariates. An external subject is considered comparable if their bias is exactly zero ($b_{i,0} = 0$) and incomparable if it is non-zero.</li> <li><strong>Initial Estimation:</strong> The framework first uses machine learning models to calculate an initial, consistent estimate of this bias ($\hat{b}_{i}$) for every single external subject.</li> <li> <table> <tbody> <tr> <td><strong>Applying the Penalty:</strong> A refined bias estimator ($\tilde{b}$) is then computed using penalized estimation. The adaptive lasso penalty term applied to each subject is proportional to $</td> <td>b_{i}</td> <td>/</td> <td>\hat{b}_{i}</td> <td>^{\nu}$.</td> </tr> </tbody> </table> </li> <li><strong>The Shrinkage Mechanism:</strong> Because the initial bias estimate ($\hat{b}<em>{i}$) acts as the denominator in the penalty term, it dictates the severity of the penalty. If an external subject is truly comparable, their initial bias estimate will be close to zero, which forces the associated penalty to become exceedingly large. This massive penalty shrinks the subject’s final, refined bias estimate ($\tilde{b}</em>{i}$) exactly to zero.</li> <li><strong>Selective Borrowing:</strong> Once the penalized estimation is complete, the framework looks at the refined bias estimates. Any external subject whose refined bias is exactly zero ($\tilde{b}_{i} = 0$) is grouped into a comparable subset ($\tilde{\mathcal{A}}$) and retained for the trial analysis, while anyone with a non-zero bias is permanently excluded.</li> </ul> <p>By using this penalty, the framework achieves “selection consistency” (Lemma 1). This means that as long as the initial estimator is high quality and the tuning parameters are chosen properly, the adaptive lasso will consistently and reliably pinpoint the zero-bias subjects, naturally filtering out incomparable external controls that could otherwise skew the trial’s results.</p> <h2 id="practical-implementation">Practical Implementation</h2> <p>To learn the exact value of the bias parameter for each external control subject, the framework uses a two-step process involving machine learning predictions followed by a penalized optimization:</p> <ol> <li><strong>Defining the True Bias:</strong> The true subject-level bias, $b_{i,0}$, is defined mathematically as the difference between the expected conditional outcome for an external control subject ($\mu_{0,E}(X_{i})$) and a concurrent trial control subject ($\mu_{0}(X_{i})$), which is expressed as $b_{i,0} = \mu_{0,E}(X_{i}) - \mu_{0}(X_{i})$.</li> <li><strong>Calculating an Initial Estimate:</strong> An initial, unpenalized estimator, $\hat{b}<em>{i}$, is constructed by calculating the difference between the estimated outcome means for both groups: $\hat{b}</em>{i} = \hat{\mu}<em>{0,E}(X</em>{i}) - \hat{\mu}<em>{0}(X</em>{i})$. In practice, these conditional outcome means ($\hat{\mu}<em>{0,E}$ and $\hat{\mu}</em>{0}$) are estimated using off-the-shelf machine learning algorithms that possess guaranteed convergence rates.</li> <li><strong>Applying the Adaptive Lasso Penalty:</strong> Finally, a refined bias estimator, $\tilde{b}$, is computed by solving a penalized least-squares optimization problem. The framework finds the vector of biases $b$ that minimizes the following equation:</li> </ol> \[\tilde{b} = \text{argmin}_{b} \{ (\hat{b}-b)^{T} \hat{\Sigma}_{b}^{-1} (\hat{b}-b) + \lambda_{N} \sum_{i \in E} p(|b_{i}|) \}\] <h3 id="breaking-down-the-components">Breaking down the components:</h3> <ul> <li>$\hat{\Sigma}_{b}$ is the estimated variance of the initial bias estimator $\hat{b}$.</li> <li> <table> <tbody> <tr> <td>$p(</td> <td>b_{i}</td> <td>)$ is the adaptive lasso penalty term applied to each subject, which is defined as $</td> <td>b_{i}</td> <td>/</td> <td>\hat{b}_{i}</td> <td>^{\nu}$.</td> </tr> </tbody> </table> </li> <li>$\lambda_{N}$ and $\nu$ are two tuning parameters that dictate the strength of the penalty; they are selected by minimizing the mean square error using cross-validation.</li> </ul> <table> <tbody> <tr> <td>Because the initial estimate $\hat{b}_{i}$ acts as the denominator in the penalty term $p(</td> <td>b_{i}</td> <td>)$, subjects who are truly comparable (and thus have an initial bias estimate close to zero) will receive an exceedingly large penalty. This dynamic successfully shrinks their final refined bias estimate ($\tilde{b}_{i}$) to exactly zero, allowing the framework to pinpoint and select them for the trial.</td> </tr> </tbody> </table>]]></content><author><name>Jong Min Moon</name></author><category term="causal_inference"/><category term="statistics"/><category term="causal-inference"/><category term="medical-statistics"/><category term="adaptive-lasso"/><category term="machine-learning"/><summary type="html"><![CDATA[A deep dive into how machine learning and adaptive lasso can enhance RCTs by selectively borrowing information from external controls.]]></summary></entry><entry><title type="html">Vibe Coding Report 1: Word Frequency Analyzer</title><link href="https://jong-min-moon.github.io/blog/2026/vibe-coding-report-1/" rel="alternate" type="text/html" title="Vibe Coding Report 1: Word Frequency Analyzer"/><published>2026-02-16T00:00:00+00:00</published><updated>2026-02-16T00:00:00+00:00</updated><id>https://jong-min-moon.github.io/blog/2026/vibe-coding-report-1</id><content type="html" xml:base="https://jong-min-moon.github.io/blog/2026/vibe-coding-report-1/"><![CDATA[<h2 id="a-prompts">A. Prompts</h2> <h3 id="prompt-1-gemini-3-pro">Prompt 1 (Gemini 3 Pro)</h3> <blockquote> <p>I am going to do vibe coding and I want you to help me write the first prompt. The problem is writing a python code that does:</p> <p><strong>Problem 1: Word Frequency Analyzer</strong> Write a program that takes in a block of text and outputs the 10 most frequent words, along with their counts. Ignore capitalization and punctuation. If two words have the same count, break ties by alphabetical order of the word. Return exactly k items if there are at least k unique words</p> <p>The input format examples are:</p> <ul> <li><strong>Input 1:</strong> “The quick brown fox jumps over the lazy dog. The dog wasn’t amused; the fox was.”</li> <li><strong>Input 2:</strong> “Data, data, data! I can’t make bricks without clay, said Sherlock. DATA drives decisions.”</li> <li><strong>Input 3:</strong> “To be, or not to be—that is the question: Whether ‘tis nobler in the mind to suffer…”</li> </ul> </blockquote> <h3 id="prompt-2-cursor">Prompt 2 (Cursor)</h3> <blockquote> <p><strong>Role &amp; Objective:</strong> Act as an expert Python developer. Write a highly optimized, clean, and well-documented Python function that acts as a Word Frequency Analyzer.</p> <p><strong>Function Signature:</strong> <code class="language-plaintext highlighter-rouge">def analyze_word_frequency(text: str, k: int = 10) -&gt; list[tuple[str, int]]:</code></p> <p><strong>Core Requirements:</strong></p> <ul> <li><strong>Parse the Text:</strong> Process the input block of text and count the frequency of each word.</li> <li><strong>Normalization:</strong> Ignore capitalization (treat “The” and “the” as identical).</li> <li><strong>Punctuation:</strong> Remove all punctuation. (Note: Please handle contractions like “wasn’t” or “can’t” by keeping them as a single word without the apostrophe, e.g., “wasnt”, OR specify if you prefer splitting them).</li> <li><strong>Sorting &amp; Tie-Breaking:</strong> Sort the output descending by frequency. If two or more words have the exact same count, break the tie by sorting those words in ascending alphabetical order.</li> <li><strong>Output Limit:</strong> Return exactly k items as a list of tuples (word, count). If the text contains fewer than k unique words, return all available unique words sorted by the same rules.</li> </ul> <p><strong>Test Cases to validate against:</strong></p> <ul> <li>Input 1: “The quick brown fox jumps over the lazy dog. The dog wasn’t amused; the fox was.”</li> <li>Input 2: “Data, data, data! I can’t make bricks without clay, said Sherlock. DATA drives decisions.”</li> <li>Input 3: “To be, or not to be—that is the question: Whether ‘tis nobler in the mind to suffer…”</li> </ul> <p>Please provide the complete Python code, including the collections or re modules if you use them, and write a quick test block at the bottom to run the three inputs.</p> </blockquote> <h3 id="prompt-3-gemini-3-pro">Prompt 3 (Gemini 3 Pro)</h3> <blockquote> <p>The cursor has generated a python code. Now write a prompt that orders it to write a test code: For each test case provided , it should clearly list the input you used and the exact output the program produced.</p> <p>the inputs are:</p> <ul> <li>Input 1: “The quick brown fox jumps over the lazy dog. The dog wasn’t amused; the fox was.”</li> <li>Input 2: “Data, data, data! I can’t make bricks without clay, said Sherlock. DATA drives decisions.”</li> <li>Input 3: “To be, or not to be—that is the question: Whether ‘tis nobler in the mind to suffer…”</li> </ul> </blockquote> <h3 id="prompt-4-cursor">Prompt 4 (Cursor)</h3> <blockquote> <p><strong>Objective:</strong> Write a test script to validate the word frequency function we just created. Do not use a silent testing framework like unittest; instead, write a script that runs the function against specific inputs and prints the results clearly to the console.</p> <p><strong>Formatting Requirements:</strong> For each test case, execute the function with k=10. The terminal output for each test case must be heavily formatted and clearly list both the raw input and the exact output. Use print statements to format it exactly like this example:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>========================================
TEST CASE 1
========================================
INPUT:
"The quick brown fox jumps over the lazy dog. The dog wasn’t amused; the fox was."

OUTPUT:
[('the', 4), ('dog', 2), ('fox', 2), ('amused', 1), ('brown', 1), ...]
</code></pre></div> </div> <p><strong>The Test Inputs:</strong> Please implement this for the following three inputs:</p> <ul> <li>Input 1: “The quick brown fox jumps over the lazy dog. The dog wasn’t amused; the fox was.”</li> <li>Input 2: “Data, data, data! I can’t make bricks without clay, said Sherlock. DATA drives decisions.”</li> <li>Input 3: “To be, or not to be—that is the question: Whether ‘tis nobler in the mind to suffer…”</li> </ul> </blockquote> <h3 id="prompt-5-gemini-3-pro">Prompt 5 (Gemini 3 Pro)</h3> <blockquote> <p>Summarize the logic of the following program. Then, comment on how the program could be improved. give me a two-paragraph summary.</p> </blockquote> <hr/> <h2 id="b-final-generated-program">B. Final Generated Program</h2> <h3 id="word_frequency_analyzerpy-main-python-code"><code class="language-plaintext highlighter-rouge">word_frequency_analyzer.py</code> (Main Python Code)</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sh">"""</span><span class="s">
Word Frequency Analyzer

Parses text, normalizes words (lowercase, no punctuation), counts frequencies,
and returns the top-k (word, count) pairs sorted by count descending with
alphabetical tie-breaking.
</span><span class="sh">"""</span>

<span class="kn">import</span> <span class="n">re</span>
<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

<span class="k">def</span> <span class="nf">analyze_word_frequency</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
    <span class="sh">"""</span><span class="s">
    Analyze word frequency in the given text and return the top-k words.

    Words are normalized: lowercased and stripped of punctuation. Contractions
    (e.g., </span><span class="sh">"</span><span class="s">wasn</span><span class="sh">'</span><span class="s">t</span><span class="sh">"</span><span class="s">, </span><span class="sh">"</span><span class="s">can</span><span class="sh">'</span><span class="s">t</span><span class="sh">"</span><span class="s">) are kept as single tokens with the apostrophe
    removed (</span><span class="sh">"</span><span class="s">wasnt</span><span class="sh">"</span><span class="s">, </span><span class="sh">"</span><span class="s">cant</span><span class="sh">"</span><span class="s">).

    Args:
        text: Input string to analyze.
        k: Maximum number of (word, count) pairs to return (default 10).

    Returns:
        List of up to k tuples (word, count), sorted by count descending.
        Ties in count are broken by word ascending alphabetically.
        Fewer than k items if the text has fewer unique words.
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">text</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">text</span><span class="p">.</span><span class="nf">strip</span><span class="p">():</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1"># Normalize: lowercase for case-insensitive counting
</span>    <span class="n">normalized</span> <span class="o">=</span> <span class="n">text</span><span class="p">.</span><span class="nf">lower</span><span class="p">()</span>

    <span class="c1"># Handle contractions: remove apostrophes so "wasn't" -&gt; "wasnt", "'tis" -&gt; "tis"
</span>    <span class="n">normalized</span> <span class="o">=</span> <span class="n">normalized</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="sh">"'"</span><span class="p">,</span> <span class="sh">""</span><span class="p">)</span>

    <span class="c1"># Remove all remaining punctuation (keep only letters, digits, spaces)
</span>    <span class="n">normalized</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nf">sub</span><span class="p">(</span><span class="sa">r</span><span class="sh">"</span><span class="s">[^a-z0-9\s]</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s"> </span><span class="sh">"</span><span class="p">,</span> <span class="n">normalized</span><span class="p">)</span>

    <span class="c1"># Split on whitespace and drop empty tokens
</span>    <span class="n">words</span> <span class="o">=</span> <span class="n">normalized</span><span class="p">.</span><span class="nf">split</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">words</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1"># Count occurrences
</span>    <span class="n">counts</span> <span class="o">=</span> <span class="nc">Counter</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>

    <span class="c1"># Sort: primary key = count descending, secondary key = word ascending
</span>    <span class="n">sorted_items</span> <span class="o">=</span> <span class="nf">sorted</span><span class="p">(</span><span class="n">counts</span><span class="p">.</span><span class="nf">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">sorted_items</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span>

<span class="c1"># ---------------------------------------------------------------------------
# Tests
# ---------------------------------------------------------------------------
</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">test_cases</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span>
            <span class="sh">"</span><span class="s">The quick brown fox jumps over the lazy dog. The dog wasn</span><span class="sh">'</span><span class="s">t amused; the fox was.</span><span class="sh">"</span><span class="p">,</span>
            <span class="mi">10</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="p">(</span>
            <span class="sh">"</span><span class="s">Data, data, data! I can</span><span class="sh">'</span><span class="s">t make bricks without clay, said Sherlock. DATA drives decisions.</span><span class="sh">"</span><span class="p">,</span>
            <span class="mi">10</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="p">(</span>
            <span class="sh">"</span><span class="s">To be, or not to be—that is the question: Whether </span><span class="sh">'</span><span class="s">tis nobler in the mind to suffer...</span><span class="sh">"</span><span class="p">,</span>
            <span class="mi">10</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">test_cases</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">--- Input </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s"> (k=</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s">) ---</span><span class="sh">"</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nf">analyze_word_frequency</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">word</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
            <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  </span><span class="si">{</span><span class="n">word</span><span class="si">!r}</span><span class="s">: </span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">()</span>
</code></pre></div></div> <h3 id="test_word_frequencypy"><code class="language-plaintext highlighter-rouge">test_word_frequency.py</code></h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sh">"""</span><span class="s">
Test script for analyze_word_frequency.
Runs the function against three fixed inputs with k=10 and prints
formatted results to the console (no unittest).
</span><span class="sh">"""</span>

<span class="kn">from</span> <span class="n">word_frequency_analyzer</span> <span class="kn">import</span> <span class="n">analyze_word_frequency</span>

<span class="n">K</span> <span class="o">=</span> <span class="mi">10</span>

<span class="n">INPUT_1</span> <span class="o">=</span> <span class="sh">"</span><span class="s">The quick brown fox jumps over the lazy dog. The dog wasn</span><span class="sh">'</span><span class="s">t amused; the fox was.</span><span class="sh">"</span>
<span class="n">INPUT_2</span> <span class="o">=</span> <span class="sh">"</span><span class="s">Data, data, data! I can</span><span class="sh">'</span><span class="s">t make bricks without clay, said Sherlock. DATA drives decisions.</span><span class="sh">"</span>
<span class="n">INPUT_3</span> <span class="o">=</span> <span class="sh">"</span><span class="s">To be, or not to be—that is the question: Whether </span><span class="sh">'</span><span class="s">tis nobler in the mind to suffer...</span><span class="sh">"</span>


<span class="k">def</span> <span class="nf">run_test</span><span class="p">(</span><span class="n">case_num</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">========================================</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">TEST CASE </span><span class="si">{</span><span class="n">case_num</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">========================================</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">INPUT:</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="nf">repr</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
    <span class="nf">print</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nf">analyze_word_frequency</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">K</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">OUTPUT:</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">()</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="nf">run_test</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">INPUT_1</span><span class="p">)</span>
    <span class="nf">run_test</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">INPUT_2</span><span class="p">)</span>
    <span class="nf">run_test</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">INPUT_3</span><span class="p">)</span>

</code></pre></div></div> <hr/> <h2 id="c-inputs-and-outputs">C. Inputs and Outputs</h2> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>========================================
TEST CASE 1
========================================
INPUT:
"The quick brown fox jumps over the lazy dog. The dog wasn't amused; the fox was."

OUTPUT:
[('the', 4), ('dog', 2), ('fox', 2), ('amused', 1), ('brown', 1), ('jumps', 1), ('lazy', 1), ('over', 1), ('quick', 1), ('was', 1)]

========================================
TEST CASE 2
========================================
INPUT:
"Data, data, data! I can't make bricks without clay, said Sherlock. DATA drives decisions."

OUTPUT:
[('data', 4), ('bricks', 1), ('cant', 1), ('clay', 1), ('decisions', 1), ('drives', 1), ('i', 1), ('make', 1), ('said', 1), ('sherlock', 1)]

========================================
TEST CASE 3
========================================
INPUT:
"To be, or not to be—that is the question: Whether 'tis nobler in the mind to suffer..."

OUTPUT:
[('to', 3), ('be', 2), ('the', 2), ('in', 1), ('is', 1), ('mind', 1), ('nobler', 1), ('not', 1), ('or', 1), ('question', 1)]
</code></pre></div></div> <hr/> <h2 id="d-ai-generated-analysis">D. AI-Generated Analysis</h2> <p>The program calculates the top k most frequent words in a string by systematically cleaning, counting, and sorting the text. It begins by converting the entire input to lowercase and manually stripping out apostrophes so that contractions are merged into single alphanumeric tokens (e.g., “wasn’t” becomes “wasnt”). Next, it uses a regular expression to replace all remaining non-alphanumeric characters with spaces, which safely removes punctuation and treats characters like em-dashes as word separators. After splitting this sanitized string into a list of words, it tallies their frequencies using <code class="language-plaintext highlighter-rouge">collections.Counter</code>. Finally, the script sorts the dictionary items using a custom lambda function—prioritizing highest counts first (<code class="language-plaintext highlighter-rouge">-x[1]</code>), while resolving ties alphabetically (<code class="language-plaintext highlighter-rouge">x[0]</code>)—and returns the top k slice.</p> <p>While the script is highly effective for basic English text, it could be improved for better scalability and internationalization. The current regular expression <code class="language-plaintext highlighter-rouge">[^a-z0-9\s]</code> strips out all non-ASCII characters, meaning accented words (like “café” or “naïve”) will be improperly fractured; swapping this for a Unicode-aware regex would make the parser much more robust. Additionally, the current sorting method evaluates the entire vocabulary of the text at once (<code class="language-plaintext highlighter-rouge">sorted(counts.items(), ...)</code>), which is inefficient for massive datasets. While <code class="language-plaintext highlighter-rouge">Counter(words).most_common()</code> doesn’t natively support alphabetical tie-breaking, implementing a custom priority queue (using the <code class="language-plaintext highlighter-rouge">heapq</code> module) to maintain only the top k elements in memory would significantly improve the algorithm’s performance on book-length inputs.</p>]]></content><author><name>Jongmin Mun</name></author><category term="vibe-coding"/><category term="distill"/><category term="formatting"/><summary type="html"><![CDATA[A report on generating a Word Frequency Analyzer using AI prompts and iterative refinement.]]></summary></entry><entry><title type="html">Vibe Coding Report: Palindrome Checker</title><link href="https://jong-min-moon.github.io/blog/2026/vibe-coding-report-2/" rel="alternate" type="text/html" title="Vibe Coding Report: Palindrome Checker"/><published>2026-02-16T00:00:00+00:00</published><updated>2026-02-16T00:00:00+00:00</updated><id>https://jong-min-moon.github.io/blog/2026/vibe-coding-report-2</id><content type="html" xml:base="https://jong-min-moon.github.io/blog/2026/vibe-coding-report-2/"><![CDATA[<h2 id="a-prompts">A. Prompts</h2> <h3 id="prompt-1-gemini-3-pro">Prompt 1 (Gemini 3 Pro)</h3> <blockquote> <p>I am going to do vibe coding and I want you to help me write the first prompt. The problem is writing a python code that follows the following instruction:</p> <p>Write a program that takes in a sentence and determines if it is a palindrome, ignoring capitalization, spaces, and punctuation. Example: “A man, a plan, a canal: Panama” → “This is a palindrome.”</p> <p>The input format examples are:</p> <ul> <li><strong>Input 1:</strong> A man, a plan, a canal: Panama!</li> <li><strong>Input 2:</strong> No ‘x’ in Nixon</li> <li><strong>Input 3:</strong> Was it a car or a cat I saw?</li> </ul> <p>Test cases must be written with these examples and the test output should clearly format and print the input and output.</p> </blockquote> <h3 id="prompt-2-cursor">Prompt 2 (Cursor)</h3> <blockquote> <p>Act as an expert Python developer. I need a Python script that checks if a given sentence is a palindrome. Here are the strict requirements for the logic:</p> <ul> <li>The checker must completely ignore capitalization, spaces, and all punctuation. Only consider alphanumeric characters.</li> <li>The output should return a clean, user-friendly string, such as ‘This is a palindrome.’ or ‘This is not a palindrome.’</li> </ul> <p><strong>Testing &amp; Output Formatting Requirements:</strong> Write a testing block that loops through a list of inputs. You must use exactly these test cases:</p> <ol> <li>“A man, a plan, a canal: Panama!”</li> <li>“No ‘x’ in Nixon”</li> <li>“Was it a car or a cat I saw?”</li> </ol> <p>When running the tests, format the console output so it clearly displays both the original input and the final evaluated output in a highly readable way. Keep the code elegant, Pythonic, and well-commented.</p> </blockquote> <h3 id="prompt-3-gemini-3-pro">Prompt 3 (Gemini 3 Pro)</h3> <blockquote> <p>Summarize the logic of the following program. Then, comment on how the program could be improved. give me a two-paragraph summary.</p> </blockquote> <hr/> <h2 id="b-final-generated-program">B. Final Generated Program</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sh">"""</span><span class="s">
Palindrome checker: ignores case, spaces, and punctuation; considers only alphanumeric characters.
Returns user-friendly messages and includes a readable test runner.
</span><span class="sh">"""</span>

<span class="kn">import</span> <span class="n">re</span>


<span class="k">def</span> <span class="nf">is_palindrome</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Return True if the string is a palindrome when considering only alphanumeric
    characters (ignoring case, spaces, and punctuation); otherwise False.
    </span><span class="sh">"""</span>
    <span class="c1"># Keep only letters and digits, then normalize to lowercase for comparison
</span>    <span class="n">cleaned</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nf">sub</span><span class="p">(</span><span class="sa">r</span><span class="sh">"</span><span class="s">[^a-zA-Z0-9]</span><span class="sh">"</span><span class="p">,</span> <span class="sh">""</span><span class="p">,</span> <span class="n">s</span><span class="p">).</span><span class="nf">lower</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">cleaned</span> <span class="o">==</span> <span class="n">cleaned</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">check_palindrome</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Check if the given sentence is a palindrome and return a user-friendly message.
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="nf">is_palindrome</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="sh">"</span><span class="s">This is a palindrome.</span><span class="sh">"</span>
    <span class="k">return</span> <span class="sh">"</span><span class="s">This is not a palindrome.</span><span class="sh">"</span>


<span class="k">def</span> <span class="nf">run_tests</span><span class="p">():</span>
    <span class="sh">"""</span><span class="s">Run the required test cases and print original input and result in a readable format.</span><span class="sh">"""</span>
    <span class="n">test_cases</span> <span class="o">=</span> <span class="p">[</span>
        <span class="sh">"</span><span class="s">A man, a plan, a canal: Panama!</span><span class="sh">"</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">No </span><span class="sh">'</span><span class="s">x</span><span class="sh">'</span><span class="s"> in Nixon</span><span class="sh">"</span><span class="p">,</span>
        <span class="sh">"</span><span class="s">Was it a car or a cat I saw?</span><span class="sh">"</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">width</span> <span class="o">=</span> <span class="mi">60</span>  <span class="c1"># For consistent column alignment
</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">=</span><span class="sh">"</span> <span class="o">*</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">9</span><span class="p">))</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">PALINDROME CHECKER — Test Results</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">=</span><span class="sh">"</span> <span class="o">*</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">9</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sentence</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">test_cases</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nf">check_palindrome</span><span class="p">(</span><span class="n">sentence</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="se">\n</span><span class="s">Test </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s">:</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Input:  </span><span class="si">{</span><span class="n">sentence</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Output: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="sh">"</span> <span class="o">+</span> <span class="sh">"</span><span class="s">=</span><span class="sh">"</span> <span class="o">*</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">9</span><span class="p">))</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="nf">run_tests</span><span class="p">()</span>
</code></pre></div></div> <hr/> <h2 id="c-inputs-and-outputs">C. Inputs and Outputs</h2> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Test 1:
  Input:  A man, a plan, a canal: Panama!
  Output: This is a palindrome.

Test 2:
  Input:  No 'x' in Nixon
  Output: This is a palindrome.

Test 3:
  Input:  Was it a car or a cat I saw?
  Output: This is a palindrome.
</code></pre></div></div> <hr/> <h2 id="d-ai-generated-analysis">D. AI-Generated Analysis</h2> <p>The provided Python program efficiently determines whether a given sentence is a palindrome by isolating its core alphanumeric characters and comparing the sequence to its reverse. At its core, the script utilizes the re (regular expression) module to strip away all spaces, punctuation, and special characters from the input string, subsequently standardizing the remaining characters to lowercase to ensure case-insensitivity. This sanitized string is then checked against a reversed slice of itself (<code class="language-plaintext highlighter-rouge">cleaned[::-1]</code>); if they match, a wrapper function returns a user-friendly confirmation message. Finally, a test-runner function iterates through a hardcoded list of specific test cases, neatly formatting and printing the original input alongside the evaluated result to the console.</p> <p>While the script is highly readable and works perfectly for standard sentences, it could be optimized for both performance and extensibility. For instance, using the slicing method (<code class="language-plaintext highlighter-rouge">[::-1]</code>) creates a full copy of the string in memory, which could cause a bottleneck with exceptionally large text inputs; replacing this with a two-pointer approach—comparing characters from the beginning and end moving inwards—would reduce the space complexity to constant $O(1)$. Additionally, the regular expression pattern is recompiled every time the function is called; defining <code class="language-plaintext highlighter-rouge">re.compile(r"[^a-zA-Z0-9]")</code> globally would yield a slight speed boost. Finally, moving the hardcoded examples into a formal testing framework like <code class="language-plaintext highlighter-rouge">pytest</code> and allowing dynamic user inputs via the command line would elevate the script from a simple experiment to a robust, production-ready tool.</p>]]></content><author><name>Jongmin Mun</name></author><category term="vibe-coding"/><category term="distill"/><category term="formatting"/><summary type="html"><![CDATA[A report on generating a Palindrome Checker using AI prompts and iterative refinement.]]></summary></entry><entry><title type="html">Vibe Coding Report: Group Anagrams</title><link href="https://jong-min-moon.github.io/blog/2026/vibe-coding-report-3/" rel="alternate" type="text/html" title="Vibe Coding Report: Group Anagrams"/><published>2026-02-16T00:00:00+00:00</published><updated>2026-02-16T00:00:00+00:00</updated><id>https://jong-min-moon.github.io/blog/2026/vibe-coding-report-3</id><content type="html" xml:base="https://jong-min-moon.github.io/blog/2026/vibe-coding-report-3/"><![CDATA[<h2 id="a-prompts">A. Prompts</h2> <p>This time, I took one further step of prompting to improve the code.</p> <h3 id="prompt-1-gemini-3-pro">Prompt 1 (Gemini 3 Pro)</h3> <blockquote> <p>I am going to do vibe coding and I want you to help me write the first prompt. The problem is writing a python code that follows the following instruction:</p> <p>Given a list of words, group together all words that are anagrams of each other. Example: Input: [“listen”, “silent”, “enlist”, “rat”, “tar”] Output: [[“listen”,”silent”,”enlist”], [“rat”,”tar”]]</p> <p>The input format examples are:</p> <ul> <li><strong>Input 1:</strong> listen silent enlist inlets google giggle rat tar art</li> <li><strong>Input 2:</strong> dusty study night thing cat act tac tacit attic tactic</li> <li><strong>Input 3:</strong> state taste tates seats asset teats teat set eats east</li> <li>(Each line can be interpreted as a space-separated list of words.)</li> </ul> <p>Test cases must be written with these examples and the test output should clearly format and print the input and output. Do not hardcode the test code. Rather, use a formal testing framework like pytest and allowing dynamic user inputs, but use the inputs I provided on that framework.</p> </blockquote> <h3 id="prompt-2-cursor">Prompt 2 (Cursor)</h3> <blockquote> <p>Act as an expert Python developer. I want you to write a clean, efficient Python script to solve the “Group Anagrams” problem, along with a robust test suite using pytest.</p> <p><strong>The Objective:</strong> Write a function that takes a space-separated string of words, parses it into a list, and groups all words that are anagrams of each other. Example: &gt; Input: “listen silent enlist rat tar” Output: [[“listen”, “silent”, “enlist”], [“rat”, “tar”]]</p> <p><strong>Testing Requirements:</strong></p> <ol> <li>Use the <code class="language-plaintext highlighter-rouge">pytest</code> framework.</li> <li>Do not just hardcode the tests sequentially. Use <code class="language-plaintext highlighter-rouge">@pytest.mark.parametrize</code> to allow for dynamic, scalable testing.</li> <li>The test cases must clearly print the input string and the resulting grouped output to the console so I can visually verify it (ensure the test uses print statements or logs that can be seen when running <code class="language-plaintext highlighter-rouge">pytest -s</code>).</li> <li>Include the ability for a user to input their own string via standard input if run as a standalone script (e.g., under <code class="language-plaintext highlighter-rouge">if __name__ == "__main__":</code>).</li> </ol> <p><strong>Use the following inputs for your parameterized tests:</strong></p> <ul> <li>Test Case 1 Input: listen silent enlist inlets google giggle rat tar art</li> <li>Test Case 2 Input: dusty study night thing cat act tac tacit attic tactic</li> <li>Test Case 3 Input: state taste tates seats asset teats teat set eats east</li> </ul> <p>Please provide the complete Python code, including the main logic and the pytest suite in a single file or clearly separated blocks, complete with type hinting and docstrings.</p> </blockquote> <h3 id="prompt-3-gemini-3-pro">Prompt 3 (Gemini 3 Pro)</h3> <blockquote> <p>Summarize the logic of the following program. Then, comment on how the program could be improved. give me a two-paragraph summary.</p> </blockquote> <h3 id="prompt-4-cursor">Prompt 4 (Cursor)</h3> <blockquote> <p>Refactor the <code class="language-plaintext highlighter-rouge">group_anagrams</code> Python script to implement the following improvements:</p> <ol> <li><strong>Algorithmic Optimization:</strong> Update the <code class="language-plaintext highlighter-rouge">group_anagrams</code> function to use a 26-element character frequency tuple as the dictionary key instead of sorting the characters. This will optimize the time complexity per word from $O(K \log K)$ to $O(K)$. You can use <code class="language-plaintext highlighter-rouge">ord(char) - ord('a')</code> to map lowercase characters to their respective indices.</li> <li><strong>Type Hinting Modernization:</strong> Completely remove the <code class="language-plaintext highlighter-rouge">from typing import List</code> import. Update all type hints across the entire file—including the function signature, variable annotations, and the pytest suite—to use modern Python built-in types (e.g., <code class="language-plaintext highlighter-rouge">list</code>, <code class="language-plaintext highlighter-rouge">dict</code>, <code class="language-plaintext highlighter-rouge">tuple</code> instead of <code class="language-plaintext highlighter-rouge">List</code>, <code class="language-plaintext highlighter-rouge">Dict</code>, <code class="language-plaintext highlighter-rouge">Tuple</code>).</li> </ol> <p>Please ensure all existing tests still pass, the interactive <code class="language-plaintext highlighter-rouge">__main__</code> block remains functional, and the docstrings are updated to reflect the new logic.</p> </blockquote> <hr/> <h2 id="b-final-generated-program">B. Final Generated Program</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sh">"""</span><span class="s">
Group Anagrams: Given a space-separated string of words, group all words that are anagrams.
Includes pytest suite with parametrized tests and optional stdin input when run as script.
</span><span class="sh">"""</span>

<span class="kn">from</span> <span class="n">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>


<span class="k">def</span> <span class="nf">_char_frequency_key</span><span class="p">(</span><span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="p">...]:</span>
    <span class="sh">"""</span><span class="s">
    Build a 26-element tuple of letter counts (a-z) for the lowercase word.

    Uses ord(char) - ord(</span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="s">) to map each letter to an index. Non-letter
    characters are ignored. O(K) per word where K = len(word).

    Returns:
        A tuple of 26 integers: count of </span><span class="sh">'</span><span class="s">a</span><span class="sh">'</span><span class="s"> at index 0, </span><span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="s"> at 1, ..., </span><span class="sh">'</span><span class="s">z</span><span class="sh">'</span><span class="s"> at 25.
    </span><span class="sh">"""</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">26</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">word</span><span class="p">.</span><span class="nf">lower</span><span class="p">():</span>
        <span class="k">if</span> <span class="sh">"</span><span class="s">a</span><span class="sh">"</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sh">"</span><span class="s">z</span><span class="sh">"</span><span class="p">:</span>
            <span class="n">counts</span><span class="p">[</span><span class="nf">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="nf">ord</span><span class="p">(</span><span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="nf">tuple</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">group_anagrams</span><span class="p">(</span><span class="n">words_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
    <span class="sh">"""</span><span class="s">
    Parse a space-separated string into words and group all anagrams together.

    Two words are anagrams if they have the same character frequencies (same
    count per letter a-z, ignoring case and non-letter characters). Keys are
    computed as 26-element frequency tuples in O(K) per word. Groups are
    returned in order of first occurrence; within each group, words keep
    their input order.

    Args:
        words_str: A single string of space-separated words.

    Returns:
        A list of lists; each inner list contains words that are anagrams
        of each other. Groups appear in order of first occurrence.

    Example:
</span><span class="gp">        &gt;&gt;&gt;</span> <span class="nf">group_anagrams</span><span class="p">(</span><span class="sh">"</span><span class="s">listen silent enlist rat tar</span><span class="sh">"</span><span class="p">)</span>
        <span class="p">[[</span><span class="sh">'</span><span class="s">listen</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">silent</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">enlist</span><span class="sh">'</span><span class="p">],</span> <span class="p">[</span><span class="sh">'</span><span class="s">rat</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">tar</span><span class="sh">'</span><span class="p">]]</span>
    <span class="sh">"""</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">words_str</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">words_str</span><span class="p">.</span><span class="nf">strip</span><span class="p">():</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="n">words</span> <span class="o">=</span> <span class="n">words_str</span><span class="p">.</span><span class="nf">split</span><span class="p">()</span>
    <span class="c1"># Key: 26-element frequency tuple (hashable); value: list of words with that signature
</span>    <span class="n">groups</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="p">...],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="nf">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nf">_char_frequency_key</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
        <span class="n">groups</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>

    <span class="c1"># Return groups in order of first occurrence (iteration order of defaultdict)
</span>    <span class="k">return</span> <span class="nf">list</span><span class="p">(</span><span class="n">groups</span><span class="p">.</span><span class="nf">values</span><span class="p">())</span>


<span class="c1"># ---------------------------------------------------------------------------
# Pytest suite (parametrized, with visible input/output via print)
# Run with: pytest group_anagrams.py -v -s
# ---------------------------------------------------------------------------
</span>
<span class="kn">import</span> <span class="n">pytest</span>


<span class="nd">@pytest.mark.parametrize</span><span class="p">(</span>
    <span class="sh">"</span><span class="s">words_str,expected</span><span class="sh">"</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="p">(</span>
            <span class="sh">"</span><span class="s">listen silent enlist inlets google giggle rat tar art</span><span class="sh">"</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="sh">"</span><span class="s">listen</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">silent</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">enlist</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">inlets</span><span class="sh">"</span><span class="p">],</span>
                <span class="p">[</span><span class="sh">"</span><span class="s">google</span><span class="sh">"</span><span class="p">],</span>
                <span class="p">[</span><span class="sh">"</span><span class="s">giggle</span><span class="sh">"</span><span class="p">],</span>
                <span class="p">[</span><span class="sh">"</span><span class="s">rat</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">tar</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">art</span><span class="sh">"</span><span class="p">],</span>
            <span class="p">],</span>
        <span class="p">),</span>
        <span class="p">(</span>
            <span class="sh">"</span><span class="s">dusty study night thing cat act tac tacit attic tactic</span><span class="sh">"</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="sh">"</span><span class="s">dusty</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">study</span><span class="sh">"</span><span class="p">],</span>
                <span class="p">[</span><span class="sh">"</span><span class="s">night</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">thing</span><span class="sh">"</span><span class="p">],</span>
                <span class="p">[</span><span class="sh">"</span><span class="s">cat</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">act</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">tac</span><span class="sh">"</span><span class="p">],</span>
                <span class="p">[</span><span class="sh">"</span><span class="s">tacit</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">attic</span><span class="sh">"</span><span class="p">],</span>
                <span class="p">[</span><span class="sh">"</span><span class="s">tactic</span><span class="sh">"</span><span class="p">],</span>
            <span class="p">],</span>
        <span class="p">),</span>
        <span class="p">(</span>
            <span class="sh">"</span><span class="s">state taste tates seats asset teats teat set eats east</span><span class="sh">"</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="sh">"</span><span class="s">state</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">taste</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">tates</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">teats</span><span class="sh">"</span><span class="p">],</span>
                <span class="p">[</span><span class="sh">"</span><span class="s">seats</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">asset</span><span class="sh">"</span><span class="p">],</span>
                <span class="p">[</span><span class="sh">"</span><span class="s">teat</span><span class="sh">"</span><span class="p">],</span>
                <span class="p">[</span><span class="sh">"</span><span class="s">set</span><span class="sh">"</span><span class="p">],</span>
                <span class="p">[</span><span class="sh">"</span><span class="s">eats</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">east</span><span class="sh">"</span><span class="p">],</span>
            <span class="p">],</span>
        <span class="p">),</span>
    <span class="p">],</span>
    <span class="n">ids</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">case_1_anagrams</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">case_2_anagrams</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">case_3_anagrams</span><span class="sh">"</span><span class="p">],</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">test_group_anagrams</span><span class="p">(</span><span class="n">words_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">expected</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Parametrized test: checks result and prints input/output for visual verification.</span><span class="sh">"""</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nf">group_anagrams</span><span class="p">(</span><span class="n">words_str</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="se">\n</span><span class="s">  Input:  </span><span class="si">{</span><span class="n">words_str</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Output: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="n">expected</span><span class="p">,</span> <span class="sa">f</span><span class="sh">"</span><span class="s">Expected </span><span class="si">{</span><span class="n">expected</span><span class="si">}</span><span class="s">, got </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="sh">"</span>


<span class="k">def</span> <span class="nf">test_group_anagrams_empty</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Empty or whitespace-only input returns empty list.</span><span class="sh">"""</span>
    <span class="k">assert</span> <span class="nf">group_anagrams</span><span class="p">(</span><span class="sh">""</span><span class="p">)</span> <span class="o">==</span> <span class="p">[]</span>
    <span class="k">assert</span> <span class="nf">group_anagrams</span><span class="p">(</span><span class="sh">"</span><span class="s">   </span><span class="sh">"</span><span class="p">)</span> <span class="o">==</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">test_group_anagrams_single_word</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Single word returns one group.</span><span class="sh">"""</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nf">group_anagrams</span><span class="p">(</span><span class="sh">"</span><span class="s">hello</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="se">\n</span><span class="s">  Input:  hello</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Output: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="p">[[</span><span class="sh">"</span><span class="s">hello</span><span class="sh">"</span><span class="p">]]</span>


<span class="c1"># ---------------------------------------------------------------------------
# Standalone script: read from stdin and print grouped anagrams
# ---------------------------------------------------------------------------
</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Group Anagrams — Enter a space-separated list of words (or leave blank to exit):</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">user_input</span> <span class="o">=</span> <span class="nf">input</span><span class="p">().</span><span class="nf">strip</span><span class="p">()</span>
    <span class="k">except</span> <span class="nb">EOFError</span><span class="p">:</span>
        <span class="n">user_input</span> <span class="o">=</span> <span class="sh">""</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">user_input</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">No input provided. Exiting.</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nf">group_anagrams</span><span class="p">(</span><span class="n">user_input</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="se">\n</span><span class="s">Input:  </span><span class="si">{</span><span class="n">user_input</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Output: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <hr/> <h2 id="c-inputs-and-outputs">C. Inputs and Outputs</h2> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>group_anagrams.py::test_group_anagrams[case_1_anagrams] 
  Input:  listen silent enlist inlets google giggle rat tar art
  Output: [['listen', 'silent', 'enlist', 'inlets'], ['google'], ['giggle'], ['rat', 'tar', 'art']]
PASSED
group_anagrams.py::test_group_anagrams[case_2_anagrams] 
  Input:  dusty study night thing cat act tac tacit attic tactic
  Output: [['dusty', 'study'], ['night', 'thing'], ['cat', 'act', 'tac'], ['tacit', 'attic'], ['tactic']]
PASSED
group_anagrams.py::test_group_anagrams[case_3_anagrams] 
  Input:  state taste tates seats asset teats teat set eats east
  Output: [['state', 'taste', 'tates', 'teats'], ['seats', 'asset'], ['teat'], ['set'], ['eats', 'east']]
PASSED
group_anagrams.py::test_group_anagrams_empty PASSED
group_anagrams.py::test_group_anagrams_single_word 
  Input:  hello
  Output: [['hello']]
PASSED
</code></pre></div></div> <hr/> <h2 id="d-ai-generated-analysis">D. AI-Generated Analysis</h2> <p>The updated Python script efficiently groups anagrams by replacing the previous sorting mechanism with a linear-time character-frequency counting approach. For each parsed word, it calls a helper function that tallies the occurrences of letters from ‘a’ to ‘z’ into a 26-element tuple, operating in strictly $O(K)$ time where $K$ is the word length. Because this fixed-length tuple is immutable, it serves as a perfect, hashable dictionary key in a defaultdict. As the script iterates through the input string, words sharing the same frequency signature are appended to the same list, and the grouped anagrams are ultimately returned in their original insertion order alongside a modern, fully typed test suite.</p> <p>While the script is highly optimized for standard English text, its strict filtering of characters outside the lowercase ‘a’ to ‘z’ range leaves room for improvement regarding edge cases and internationalization. Because it silently ignores numbers, punctuation, and Unicode characters (like accented letters), strings with entirely different non-alphabetical characters could be incorrectly grouped together as anagrams if their base English letter counts match. To make the program universally robust, you could replace the fixed 26-element array with a <code class="language-plaintext highlighter-rouge">frozenset</code> derived from <code class="language-plaintext highlighter-rouge">collections.Counter(word.lower())</code>, which would safely and accurately hash any character from any language while maintaining excellent performance and actually shrinking the codebase.</p>]]></content><author><name>Jongmin Mun</name></author><category term="vibe-coding"/><category term="distill"/><category term="formatting"/><summary type="html"><![CDATA[A report on generating a Group Anagrams script using AI prompts and iterative refinement.]]></summary></entry><entry><title type="html">Vibe Coding Report: Recursive Maze Solver</title><link href="https://jong-min-moon.github.io/blog/2026/vibe-coding-report-4/" rel="alternate" type="text/html" title="Vibe Coding Report: Recursive Maze Solver"/><published>2026-02-16T00:00:00+00:00</published><updated>2026-02-16T00:00:00+00:00</updated><id>https://jong-min-moon.github.io/blog/2026/vibe-coding-report-4</id><content type="html" xml:base="https://jong-min-moon.github.io/blog/2026/vibe-coding-report-4/"><![CDATA[<h2 id="a-prompts">A. Prompts</h2> <p>This time, I did two iterative steps of prompting to build and improve the code.</p> <h3 id="prompt-1-gemini-3-pro">Prompt 1 (Gemini 3 Pro)</h3> <blockquote> <p>I am going to do vibe coding and I want you to help me write the first prompt. The problem is writing a python code that follows the following instruction:</p> <p><strong>Problem 4: Recursive Maze Solver (Basic)</strong> A maze is represented as a grid of 0s and 1s in text form (for example, each line of text corresponds to a row). 0 means open, 1 means wall. Write a program that finds a path from the top-left corner to the bottom-right corner, if one exists, and prints it. The grid is assumed to be rectangular, with all lines having equal length.</p> <p>The input format examples are:</p> <p>(Each maze is a text grid of 0/1; top-left is start, bottom-right is goal. You can input each of these as a matrix e.g., numpy array, or as a list of lists. Whatever decision you make for the input format is fine, as long as it’s reasonable and you can use it for all three inputs below; the same note applies also to Problem 5)</p> <ul> <li><strong>Input 1</strong> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0010
0010
0000
0110
0000
</code></pre></div> </div> </li> <li><strong>Input 2</strong> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>000
110
010
010
000
</code></pre></div> </div> </li> <li><strong>Input 3 (no valid path—should be handled gracefully)</strong> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>010
111
010
000
</code></pre></div> </div> </li> </ul> <p>Test cases must be written with these examples and the test output should clearly format and print the input and output. Do not hardcode the test code. Rather, use a formal testing framework like pytest and allowing dynamic user inputs, but use the inputs I provided on that framework.</p> </blockquote> <h3 id="prompt-2-cursor">Prompt 2 (Cursor)</h3> <blockquote> <p>Act as an expert Python developer. I want you to write a Python solution for a “Recursive Maze Solver” along with a robust pytest test suite.</p> <p><strong>The Problem:</strong> A maze is represented as a grid of 0s and 1s. 0 means open space, and 1 means a wall. Write a program that recursively finds a path from the top-left corner (0, 0) to the bottom-right corner, if one exists, and returns/prints it. The grid is rectangular.</p> <p><strong>Implementation Details:</strong></p> <ol> <li>Choose a reasonable input format for the maze (e.g., a list of lists of integers, or a NumPy array) and stick to it.</li> <li>The solver must use a recursive approach (like Depth-First Search with backtracking).</li> <li>It should return the path as a list of coordinate tuples (e.g., <code class="language-plaintext highlighter-rouge">[(0,0), (1,0), ...]</code>) or return a clear indicator (like <code class="language-plaintext highlighter-rouge">None</code> or an empty list) if no path exists.</li> </ol> <p><strong>Testing Requirements:</strong></p> <ol> <li>Use the <code class="language-plaintext highlighter-rouge">pytest</code> framework. Do not just write a basic <code class="language-plaintext highlighter-rouge">if __name__ == "__main__":</code> block.</li> <li>Use <code class="language-plaintext highlighter-rouge">@pytest.mark.parametrize</code> to dynamically pass the following 3 test cases into the test function.</li> <li>Within the test, clearly print the formatted input grid, followed by the output path (or a “No valid path” message) so that when run with <code class="language-plaintext highlighter-rouge">pytest -s</code>, the user can visually verify the results.</li> </ol> <p><strong>Test Cases to Parameterize:</strong></p> <ul> <li>Input 1 (Valid Path Expected): <code class="language-plaintext highlighter-rouge">0010 0010 0000 0110 0000</code></li> <li>Input 2 (Valid Path Expected): <code class="language-plaintext highlighter-rouge">000 110 010 010 000</code></li> <li>Input 3 (No Valid Path - Handle Gracefully): <code class="language-plaintext highlighter-rouge">010 111 010 000</code></li> </ul> <p>Please output the complete, runnable Python script containing both the solver class/function and the pytest suite.</p> </blockquote> <h3 id="prompt-3-gemini-3-pro">Prompt 3 (Gemini 3 Pro)</h3> <blockquote> <p>Summarize the logic of the following program. Then, comment on how the program could be improved. give me a two-paragraph summary.</p> </blockquote> <hr/> <h2 id="b-final-generated-program">B. Final Generated Program</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sh">"""</span><span class="s">
Recursive Maze Solver: Finds a path from top-left (0,0) to bottom-right using DFS with backtracking.
Maze format: list of lists of integers; 0 = open, 1 = wall.
</span><span class="sh">"""</span>

<span class="kn">from</span> <span class="n">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>


<span class="k">def</span> <span class="nf">solve_maze</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">|</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Find a path from (0, 0) to the bottom-right corner of the grid using recursive DFS with backtracking.

    Args:
        grid: Rectangular grid of 0s (open) and 1s (wall). Must be non-empty.

    Returns:
        A list of (row, col) coordinate tuples from start to end, or None if no path exists.
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">grid</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">grid</span><span class="p">[</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="n">visited</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>
    <span class="n">path</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">_in_bounds</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">cols</span>

    <span class="k">def</span> <span class="nf">_dfs</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="nf">if </span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
            <span class="n">path</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nf">_in_bounds</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">or</span> <span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="n">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
        <span class="n">path</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">dr</span><span class="p">,</span> <span class="n">dc</span> <span class="ow">in</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nf">_dfs</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">dr</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="n">dc</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>

        <span class="n">path</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="n">visited</span><span class="p">.</span><span class="nf">discard</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="nf">_dfs</span><span class="p">(</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">return</span> <span class="n">path</span>
    <span class="k">return</span> <span class="bp">None</span>


<span class="k">def</span> <span class="nf">grid_from_string</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
    <span class="sh">"""</span><span class="s">
    Parse a multi-line string of 0s and 1s (one row per line) into a grid.

    Example:
</span><span class="gp">        &gt;&gt;&gt;</span> <span class="nf">grid_from_string</span><span class="p">(</span><span class="sh">"</span><span class="s">01</span><span class="se">\\</span><span class="s">n10</span><span class="sh">"</span><span class="p">)</span>
        <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
    <span class="sh">"""</span>
    <span class="k">return</span> <span class="p">[[</span><span class="nf">int</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">line</span><span class="p">.</span><span class="nf">strip</span><span class="p">()]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">s</span><span class="p">.</span><span class="nf">strip</span><span class="p">().</span><span class="nf">splitlines</span><span class="p">()</span> <span class="k">if</span> <span class="n">line</span><span class="p">.</span><span class="nf">strip</span><span class="p">()]</span>


<span class="k">def</span> <span class="nf">format_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Return a readable string representation of the grid.</span><span class="sh">"""</span>
    <span class="k">return</span> <span class="sh">"</span><span class="se">\n</span><span class="sh">"</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">)</span>


<span class="c1"># ---------------------------------------------------------------------------
# Pytest suite (parametrized, with visible grid and path via print)
# Run with: pytest maze_solver.py -v -s
# ---------------------------------------------------------------------------
</span>
<span class="kn">import</span> <span class="n">pytest</span>


<span class="nd">@pytest.mark.parametrize</span><span class="p">(</span>
    <span class="sh">"</span><span class="s">grid_str,has_path</span><span class="sh">"</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="p">(</span>
            <span class="sh">"""</span><span class="s">
            0010
            0010
            0000
            0110
            0000
            </span><span class="sh">"""</span><span class="p">,</span>
            <span class="bp">True</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="p">(</span>
            <span class="sh">"""</span><span class="s">
            000
            110
            010
            010
            000
            </span><span class="sh">"""</span><span class="p">,</span>
            <span class="bp">True</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="p">(</span>
            <span class="sh">"""</span><span class="s">
            010
            111
            010
            000
            </span><span class="sh">"""</span><span class="p">,</span>
            <span class="bp">False</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">],</span>
    <span class="n">ids</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">valid_path_1</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">valid_path_2</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">no_path</span><span class="sh">"</span><span class="p">],</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">test_maze_solver</span><span class="p">(</span><span class="n">grid_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">has_path</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Parametrized test: prints grid and path (or </span><span class="sh">'</span><span class="s">No valid path</span><span class="sh">'</span><span class="s">) for visual verification.</span><span class="sh">"""</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="nf">grid_from_string</span><span class="p">(</span><span class="n">grid_str</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nf">solve_maze</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="se">\n</span><span class="s">  Grid (</span><span class="si">{</span><span class="n">rows</span><span class="si">}</span><span class="s">x</span><span class="si">{</span><span class="n">cols</span><span class="si">}</span><span class="s">):</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">  </span><span class="sh">"</span> <span class="o">+</span> <span class="nf">format_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">).</span><span class="nf">replace</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="se">\n</span><span class="s">  </span><span class="sh">"</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">result</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Path (</span><span class="si">{</span><span class="nf">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="si">}</span><span class="s"> steps): </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="sh">"</span><span class="s">Path must start at (0, 0)</span><span class="sh">"</span>
        <span class="k">assert</span> <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">end</span><span class="p">,</span> <span class="sh">"</span><span class="s">Path must end at bottom-right</span><span class="sh">"</span>
        <span class="k">assert</span> <span class="n">has_path</span><span class="p">,</span> <span class="sh">"</span><span class="s">Expected a valid path</span><span class="sh">"</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">  No valid path.</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">has_path</span><span class="p">,</span> <span class="sh">"</span><span class="s">Expected no path</span><span class="sh">"</span>

    <span class="nf">assert </span><span class="p">(</span><span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nf">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">has_path</span>


<span class="k">def</span> <span class="nf">test_maze_solver_empty</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Empty grid returns None.</span><span class="sh">"""</span>
    <span class="k">assert</span> <span class="nf">solve_maze</span><span class="p">([])</span> <span class="ow">is</span> <span class="bp">None</span>
    <span class="k">assert</span> <span class="nf">solve_maze</span><span class="p">([[]])</span> <span class="ow">is</span> <span class="bp">None</span>


<span class="k">def</span> <span class="nf">test_maze_solver_single_cell</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Single open cell is a trivial path.</span><span class="sh">"""</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nf">solve_maze</span><span class="p">([[</span><span class="mi">0</span><span class="p">]])</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="se">\n</span><span class="s">  Grid: [[0]]</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Path: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">test_maze_solver_start_or_end_wall</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">If start or end is a wall, return None.</span><span class="sh">"""</span>
    <span class="k">assert</span> <span class="nf">solve_maze</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span> <span class="ow">is</span> <span class="bp">None</span>
    <span class="k">assert</span> <span class="nf">solve_maze</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span> <span class="ow">is</span> <span class="bp">None</span>


<span class="c1"># ---------------------------------------------------------------------------
# Standalone: run solver on a small example
# ---------------------------------------------------------------------------
</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">example</span> <span class="o">=</span> <span class="nf">grid_from_string</span><span class="p">(</span>
        <span class="sh">"""</span><span class="s">
        0010
        0010
        0000
        0110
        0000
        </span><span class="sh">"""</span>
    <span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Maze:</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="nf">format_grid</span><span class="p">(</span><span class="n">example</span><span class="p">))</span>
    <span class="n">path</span> <span class="o">=</span> <span class="nf">solve_maze</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="se">\n</span><span class="s">Path: </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">No valid path.</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <hr/> <h2 id="c-inputs-and-outputs">C. Inputs and Outputs</h2> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>maze_solver.py::test_maze_solver[valid_path_1] 
  Grid (5x4):
  0010
  0010
  0000
  0110
  0000
  Path (8 steps): [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2), (2, 3), (3, 3), (4, 3)]
PASSED
maze_solver.py::test_maze_solver[valid_path_2] 
  Grid (5x3):
  000
  110
  010
  010
  000
  Path (7 steps): [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (3, 2), (4, 2)]
PASSED
maze_solver.py::test_maze_solver[no_path] 
  Grid (4x3):
  010
  111
  010
  000
  No valid path.
PASSED
maze_solver.py::test_maze_solver_empty PASSED
maze_solver.py::test_maze_solver_single_cell 
  Grid: [[0]]
  Path: [(0, 0)]
PASSED
</code></pre></div></div> <hr/> <h2 id="d-ai-generated-analysis">D. AI-Generated Analysis</h2> <p>The provided Python program implements a Depth-First Search (DFS) algorithm with backtracking to find a route through a grid-based maze. It begins by validating the grid, immediately returning None if the matrix is empty or if the starting or ending cells are walls. A nested recursive helper function, <code class="language-plaintext highlighter-rouge">_dfs</code>, handles the core traversal by exploring adjacent cells in a specific order (right, down, left, up). As it navigates, it appends the current coordinates to a path list and marks them in a visited set to prevent getting stuck in infinite loops. If the algorithm encounters a dead end, it backtracks by popping the current cell from the path and discarding it from the visited set, continuing this trial-and-error process until it either reaches the bottom-right goal or exhausts all possible routes.</p> <p>While the code is well-formatted and includes a robust pytest suite, the algorithm itself has a critical performance flaw and room for architectural improvement. The inclusion of <code class="language-plaintext highlighter-rouge">visited.discard((r, c))</code> during backtracking forces the program to “forget” dead ends, allowing alternative paths to redundantly explore known bad routes; this severely degrades performance to exponential time complexity on open grids, and removing that single line would instantly optimize the search to run in linear time, or $O(R \times C)$. Furthermore, because it relies on the Python call stack, deep recursions in large mazes will eventually trigger a <code class="language-plaintext highlighter-rouge">RecursionError</code>, a limitation that an iterative stack-based approach would completely avoid. Finally, DFS only guarantees finding any path rather than the optimal one. Would you like me to rewrite this solver using a Breadth-First Search (BFS) algorithm so that it always finds the shortest possible path?</p>]]></content><author><name>Jongmin Mun</name></author><category term="vibe-coding"/><category term="distill"/><category term="formatting"/><summary type="html"><![CDATA[A report on generating a Recursive Maze Solver using AI prompts and iterative refinement.]]></summary></entry><entry><title type="html">Vibe Coding Report: Advanced Recursive Maze Solver</title><link href="https://jong-min-moon.github.io/blog/2026/vibe-coding-report-5/" rel="alternate" type="text/html" title="Vibe Coding Report: Advanced Recursive Maze Solver"/><published>2026-02-16T00:00:00+00:00</published><updated>2026-02-16T00:00:00+00:00</updated><id>https://jong-min-moon.github.io/blog/2026/vibe-coding-report-5</id><content type="html" xml:base="https://jong-min-moon.github.io/blog/2026/vibe-coding-report-5/"><![CDATA[<h2 id="a-prompts">A. Prompts</h2> <p>I start from the last prompt and answer from problem 4.</p> <h3 id="prompt-1-gemini-3-pro">Prompt 1 (Gemini 3 Pro)</h3> <blockquote> <p>Starting from current code and problem, I want to extend the problem and modify the code accordingly. I am going to do vibe coding and I want you to help me write the first prompt. The problem is writing a python code that follows the following instruction:</p> <p><strong>Problem 5: Recursive Maze Solver (Advanced)</strong> Extend the previous problem to handle more complex rules:</p> <ul> <li>The maze may contain special symbols: <ul> <li>S for start,</li> <li>E for exit,</li> <li>T for teleport pads (any T can teleport to any other T in one step, or in other words, from one T you can move to another T in the grid in 1 step).</li> </ul> </li> <li>Your program should find the shortest path from S to E, making use of teleports if they help. For every move (including a teleport) assume the cost is 1.</li> <li>Output the path as a sequence of coordinates or directions. Return None if there is no path.</li> </ul> <p>The input format examples are:</p> <p><strong>Input 1 (simple S→E, no teleports)</strong></p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S00
110
00E
</code></pre></div> </div> <p><strong>Input 2 (teleports help bypass a wall)</strong></p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S1T001
111101
0000T1
101111
10000E
</code></pre></div> </div> <p><strong>Input 3 (multiple teleports; shortest path requires choosing the right T)</strong></p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S001T0
110110
T00010
0111T0
00010E
</code></pre></div> </div> <p>Test cases must be written with these examples and the test output should clearly format and print the input and output.</p> </blockquote> <h3 id="prompt-2-cursor">Prompt 2 (Cursor)</h3> <blockquote> <p>Act as an expert Python developer. I want to extend our previous maze solver to handle a new set of rules. Please write a Python solution for “Problem 5: Recursive Maze Solver (Advanced)” along with a robust pytest test suite.</p> <p><strong>The Problem:</strong> The maze is represented as a grid of characters:</p> <ul> <li>S: Start</li> <li>E: Exit</li> <li>T: Teleport pad</li> <li>0: Open space</li> <li>1: Wall</li> </ul> <p><strong>Implementation Details:</strong></p> <ol> <li><strong>Shortest Path:</strong> You must find the shortest path from S to E. Because we need the shortest path, please use a Breadth-First Search (BFS) algorithm using a queue, rather than standard recursive DFS.</li> <li><strong>Teleporters:</strong> Any T can teleport to any other T in the grid in exactly 1 step (cost = 1). All standard moves (up, down, left, right) also cost 1.</li> <li><strong>Output:</strong> Return the path as a sequence of coordinate tuples <code class="language-plaintext highlighter-rouge">[(r, c), (r, c), ...]</code> starting at S and ending at E. Return <code class="language-plaintext highlighter-rouge">None</code> if there is no valid path.</li> <li><strong>Parsing:</strong> Write a helper function to parse multi-line strings of these characters into your chosen grid data structure.</li> </ol> <p><strong>Testing Requirements:</strong></p> <ol> <li>Use the <code class="language-plaintext highlighter-rouge">pytest</code> framework.</li> <li>Use <code class="language-plaintext highlighter-rouge">@pytest.mark.parametrize</code> to dynamically pass the 3 test cases below into the test function.</li> <li>Within the test, clearly print the formatted input grid, followed by the output path length and the path itself so the user can visually verify the results when running <code class="language-plaintext highlighter-rouge">pytest -s</code>.</li> </ol> <p><strong>Test Cases to Parameterize:</strong></p> <ul> <li>Input 1 (Simple S→E, no teleports): <code class="language-plaintext highlighter-rouge">S00 110 00E</code></li> <li>Input 2 (Teleports help bypass a wall): <code class="language-plaintext highlighter-rouge">S1T001 111101 0000T1 101111 10000E</code></li> <li>Input 3 (Multiple teleports; shortest path requires choosing the right T): <code class="language-plaintext highlighter-rouge">S001T0 110110 T00010 0111T0 00010E</code></li> </ul> <p>Please output the complete, runnable Python script containing both the solver and the pytest suite.</p> </blockquote> <h3 id="prompt-3-gemini-3-pro">Prompt 3 (Gemini 3 Pro)</h3> <blockquote> <p>Summarize the logic of the following program. Then, comment on how the program could be improved. give me a two-paragraph summary.</p> </blockquote> <hr/> <h2 id="b-final-generated-program">B. Final Generated Program</h2> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sh">"""</span><span class="s">
Advanced Maze Solver: Shortest path from S to E using BFS, with teleport pads (T).
Grid: S = start, E = exit, T = teleport (any T → any other T in 1 step), 0 = open, 1 = wall.
</span><span class="sh">"""</span>

<span class="kn">from</span> <span class="n">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>


<span class="k">def</span> <span class="nf">parse_maze</span><span class="p">(</span><span class="n">grid_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
    <span class="sh">"""</span><span class="s">
    Parse a multi-line string of maze characters into a grid.

    Allowed characters: S (start), E (exit), T (teleport), 0 (open), 1 (wall).
    Leading/trailing whitespace on each line is stripped.

    Returns:
        A rectangular grid (list of lists of single-character strings).
    </span><span class="sh">"""</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="p">[</span><span class="n">ch</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">line</span><span class="p">.</span><span class="nf">strip</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">grid_str</span><span class="p">.</span><span class="nf">strip</span><span class="p">().</span><span class="nf">splitlines</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">line</span><span class="p">.</span><span class="nf">strip</span><span class="p">()</span>
    <span class="p">]</span>


<span class="k">def</span> <span class="nf">find_cells</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="bp">None</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="bp">None</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]]:</span>
    <span class="sh">"""</span><span class="s">
    Locate start (S), exit (E), and all teleport pads (T) in the grid.

    Returns:
        (start, end, list_of_teleports). Any of start/end may be None if not found.
    </span><span class="sh">"""</span>
    <span class="n">start</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">end</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">teleports</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">cell</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cell</span> <span class="o">==</span> <span class="sh">"</span><span class="s">S</span><span class="sh">"</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">cell</span> <span class="o">==</span> <span class="sh">"</span><span class="s">E</span><span class="sh">"</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">cell</span> <span class="o">==</span> <span class="sh">"</span><span class="s">T</span><span class="sh">"</span><span class="p">:</span>
                <span class="n">teleports</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">teleports</span>


<span class="k">def</span> <span class="nf">format_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Return a readable string representation of the grid.</span><span class="sh">"""</span>
    <span class="k">return</span> <span class="sh">"</span><span class="se">\n</span><span class="sh">"</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="sh">""</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">cell</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">solve_maze_advanced</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">|</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Find the shortest path from S to E using BFS. Moves are up/down/left/right (cost 1)
    or teleport from any T to any other T (cost 1). Returns the path as a list of
    (row, col) tuples from S to E, or None if no path exists.
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">grid</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">teleport_list</span> <span class="o">=</span> <span class="nf">find_cells</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">end</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="c1"># Walls: only '1' blocks movement. S, E, T, 0 are traversable.
</span>    <span class="k">def</span> <span class="nf">_is_wall</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">grid</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="sh">"</span><span class="s">1</span><span class="sh">"</span>

    <span class="k">def</span> <span class="nf">_in_bounds</span><span class="p">(</span><span class="n">r</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">cols</span>

    <span class="c1"># BFS with parent pointers for path reconstruction
</span>    <span class="n">parent</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="bp">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">start</span><span class="p">:</span> <span class="bp">None</span><span class="p">}</span>
    <span class="n">queue</span><span class="p">:</span> <span class="n">deque</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">start</span><span class="p">])</span>

    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
        <span class="nf">if </span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
            <span class="c1"># Reconstruct path from E back to S
</span>            <span class="n">path</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cur</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="n">end</span>
            <span class="k">while</span> <span class="n">cur</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">path</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">cur</span><span class="p">]</span>
            <span class="n">path</span><span class="p">.</span><span class="nf">reverse</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">path</span>

        <span class="c1"># Standard moves: up, down, left, right
</span>        <span class="k">for</span> <span class="n">dr</span><span class="p">,</span> <span class="n">dc</span> <span class="ow">in</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">dr</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="n">dc</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nf">_in_bounds</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="nf">_is_wall</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="nf">if </span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">parent</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">parent</span><span class="p">[(</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">))</span>

        <span class="c1"># If current cell is a teleport, add all other teleports as one-step neighbors
</span>        <span class="nf">if </span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">teleport_list</span><span class="p">:</span>
            <span class="nf">for </span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">tc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">teleport_list</span><span class="p">:</span>
                <span class="nf">if </span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">tc</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="nf">if </span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">tc</span><span class="p">)</span> <span class="ow">in</span> <span class="n">parent</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">parent</span><span class="p">[(</span><span class="n">tr</span><span class="p">,</span> <span class="n">tc</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">tr</span><span class="p">,</span> <span class="n">tc</span><span class="p">))</span>

    <span class="k">return</span> <span class="bp">None</span>


<span class="c1"># ---------------------------------------------------------------------------
# Pytest suite (parametrized, with visible grid and path)
# Run with: pytest maze_solver_advanced.py -v -s
# ---------------------------------------------------------------------------
</span>
<span class="kn">import</span> <span class="n">pytest</span>


<span class="nd">@pytest.mark.parametrize</span><span class="p">(</span>
    <span class="sh">"</span><span class="s">grid_str,has_path</span><span class="sh">"</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="p">(</span>
            <span class="sh">"""</span><span class="s">
            S00
            110
            00E
            </span><span class="sh">"""</span><span class="p">,</span>
            <span class="bp">True</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="p">(</span>
            <span class="sh">"""</span><span class="s">
            S1T001
            111101
            0000T1
            101111
            10000E
            </span><span class="sh">"""</span><span class="p">,</span>
            <span class="bp">False</span><span class="p">,</span>  <span class="c1"># S has no adjacent open cell in this grid; no path
</span>        <span class="p">),</span>
        <span class="p">(</span>
            <span class="sh">"""</span><span class="s">
            S001T0
            110110
            T00010
            0111T0
            00010E
            </span><span class="sh">"""</span><span class="p">,</span>
            <span class="bp">True</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">],</span>
    <span class="n">ids</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">simple_s_to_e</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">teleports_bypass_wall</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">multiple_teleports</span><span class="sh">"</span><span class="p">],</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">test_maze_solver_advanced</span><span class="p">(</span><span class="n">grid_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">has_path</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Parametrized test: prints grid, path length, and path for visual verification.</span><span class="sh">"""</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="nf">parse_maze</span><span class="p">(</span><span class="n">grid_str</span><span class="p">)</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nf">find_cells</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nf">solve_maze_advanced</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="se">\n</span><span class="s">  Grid:</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">  </span><span class="sh">"</span> <span class="o">+</span> <span class="nf">format_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">).</span><span class="nf">replace</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="se">\n</span><span class="s">  </span><span class="sh">"</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Path length: </span><span class="si">{</span><span class="nf">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Path: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">start</span><span class="p">,</span> <span class="sh">"</span><span class="s">Path must start at S</span><span class="sh">"</span>
        <span class="k">assert</span> <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">end</span><span class="p">,</span> <span class="sh">"</span><span class="s">Path must end at E</span><span class="sh">"</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">  No valid path.</span><span class="sh">"</span><span class="p">)</span>

    <span class="nf">assert </span><span class="p">(</span><span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="o">==</span> <span class="n">has_path</span>


<span class="k">def</span> <span class="nf">test_parse_maze</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Parser produces correct grid and find_cells locates S, E, T.</span><span class="sh">"""</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="nf">parse_maze</span><span class="p">(</span><span class="sh">"</span><span class="s">S0</span><span class="se">\n</span><span class="s">1E</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">grid</span> <span class="o">==</span> <span class="p">[[</span><span class="sh">"</span><span class="s">S</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">0</span><span class="sh">"</span><span class="p">],</span> <span class="p">[</span><span class="sh">"</span><span class="s">1</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">E</span><span class="sh">"</span><span class="p">]]</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="nf">find_cells</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">start</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">end</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">t</span> <span class="o">==</span> <span class="p">[]</span>

    <span class="n">grid2</span> <span class="o">=</span> <span class="nf">parse_maze</span><span class="p">(</span><span class="sh">"</span><span class="s">ST</span><span class="se">\n</span><span class="s">00</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="nf">find_cells</span><span class="p">(</span><span class="n">grid2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">t2</span> <span class="o">==</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">test_no_path</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Grid with S and E but no path returns None.</span><span class="sh">"""</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="nf">parse_maze</span><span class="p">(</span>
        <span class="sh">"""</span><span class="s">
        S11
        111
        11E
        </span><span class="sh">"""</span>
    <span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="nf">solve_maze_advanced</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="se">\n</span><span class="s">  Grid: S and E surrounded by walls</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">  Path: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">None</span>


<span class="k">def</span> <span class="nf">test_empty_grid</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">Empty grid returns None.</span><span class="sh">"""</span>
    <span class="k">assert</span> <span class="nf">solve_maze_advanced</span><span class="p">([])</span> <span class="ow">is</span> <span class="bp">None</span>
    <span class="k">assert</span> <span class="nf">solve_maze_advanced</span><span class="p">([[]])</span> <span class="ow">is</span> <span class="bp">None</span>


<span class="c1"># ---------------------------------------------------------------------------
# Standalone: run on first test maze
# ---------------------------------------------------------------------------
</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">example</span> <span class="o">=</span> <span class="sh">"""</span><span class="s">
    S00
    110
    00E
    </span><span class="sh">"""</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="nf">parse_maze</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Maze:</span><span class="sh">"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="nf">format_grid</span><span class="p">(</span><span class="n">grid</span><span class="p">))</span>
    <span class="n">path</span> <span class="o">=</span> <span class="nf">solve_maze_advanced</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">path</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="se">\n</span><span class="s">Path length: </span><span class="si">{</span><span class="nf">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Path: </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="se">\n</span><span class="s">No valid path.</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <hr/> <h2 id="c-inputs-and-outputs">C. Inputs and Outputs</h2> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>maze_solver.py::test_maze_solver[valid_path_1] 
  Grid (5x4):
  0010
  0010
  0000
  0110
  0000
  Path (8 steps): [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2), (2, 3), (3, 3), (4, 3)]
PASSED
maze_solver.py::test_maze_solver[valid_path_2] 
  Grid (5x3):
  000
  110
  010
  010
  000
  Path (7 steps): [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (3, 2), (4, 2)]
PASSED
maze_solver.py::test_maze_solver[no_path] 
  Grid (4x3):
  010
  111
  010
  000
  No valid path.
PASSED
maze_solver.py::test_maze_solver_empty PASSED
maze_solver.py::test_maze_solver_single_cell 
  Grid: [[0]]
  Path: [(0, 0)]
PASSED
</code></pre></div></div> <hr/> <h2 id="d-ai-generated-analysis">D. AI-Generated Analysis</h2> <p>This generated program successfully shifts the architecture to an iterative Breadth-First Search (BFS) to guarantee the shortest path through the maze. It begins by parsing the text grid and identifying the coordinates of the start (S), exit (E), and all teleporter (T) pads. Using a deque for efficient first-in-first-out processing, the algorithm evaluates standard adjacent moves while treating any reached teleporter as having immediate one-step connections to all other teleporters. As it traverses, it maps each newly visited cell to its predecessor in a parent dictionary. This prevents infinite loops and provides the exact breadcrumb trail needed to reverse-engineer the optimal route once the exit is discovered.</p> <p>While the fundamental BFS logic is solid, the program could be improved both algorithmically and conceptually. Most amusingly, your AI agent realized that your “Input 2” grid accidentally traps the starting node behind walls, so rather than alerting you to the unsolvable maze, it cheekily changed your test assertion to expect False! Algorithmically, the teleporter logic is computationally inefficient; currently, every time any teleporter is visited, the code loops through the entire teleporter list again. Since all teleporters share a single unified network, the program should trigger the teleporters once, add them to the queue, and then mark the network as “exhausted” to eliminate redundant $O(T^2)$ checking.</p>]]></content><author><name>Jongmin Mun</name></author><category term="vibe-coding"/><category term="distill"/><category term="formatting"/><summary type="html"><![CDATA[A report on generating an Advanced Recursive Maze Solver (BFS with Teleports) using AI prompts.]]></summary></entry><entry><title type="html">Retrieval-Augmented Generation (RAG)</title><link href="https://jong-min-moon.github.io/blog/2026/rag/" rel="alternate" type="text/html" title="Retrieval-Augmented Generation (RAG)"/><published>2026-02-15T00:00:00+00:00</published><updated>2026-02-15T00:00:00+00:00</updated><id>https://jong-min-moon.github.io/blog/2026/rag</id><content type="html" xml:base="https://jong-min-moon.github.io/blog/2026/rag/"><![CDATA[<h2 id="i-the-core-problem">I. The Core Problem</h2> <p>Large Language Models (LLMs) operate much like a knowledgeable friend trying to answer your questions. However, even a smart friend can make mistakes:</p> <ol> <li><strong>Stale Information:</strong> They might rely on outdated facts (e.g., “The Queen is the monarch of England”).</li> <li><strong>Unreliability of the Source:</strong> We don’t know where this information came from.</li> </ol> <p>This happens because their knowledge is limited to what they learned in the past. If I want to give you a correct answer, I should <strong>search the web</strong> references rather than relying solely on my memory.</p> <p><strong>Same for LLMs!</strong> The training data used to train the model is static—it’s essentially “last year’s data.” To fix this, we need to give the LLM access to external tools.</p> <hr/> <h2 id="ii-the-solution-vector-database">II. The Solution: Vector Database</h2> <p>To provide the LLM with up-to-date information, we connect it to a <strong>Vector Database</strong>. A vector database stores various types of documents (PDFs, text files, APIs) as <strong>vector embeddings</strong>—numerical representations of the semantic meaning of the text.</p> <p>Before answering a user’s question, the system searches this database for verifiable facts. If relevant information exists, it is retrieved and fed to the LLM.</p> <hr/> <h2 id="iii-the-workflow">III. The Workflow</h2> <p>The key difference between a standard LLM interaction and RAG is the intermediate search step.</p> <h3 id="without-rag">Without RAG</h3> <p>The user asks a question, and the model answers directly from its frozen training weights.</p> <blockquote> <p><strong>User Prompt</strong> $\rightarrow$ <strong>Answer from Parametric Memory</strong></p> </blockquote> <h3 id="with-rag">With RAG</h3> <p>The system instructs the model to look at the database and combine that information with the user’s prompt.</p> <ol> <li><strong>Instruction:</strong> “Look at the database and combine the retrieved context with the user’s prompt to answer.”</li> <li><strong>Search:</strong> The system embeds the user’s prompt and finds the closest matching vectors in the database.</li> <li><strong>Augmentation:</strong> The retrieved context + the original prompt are sent to the LLM.</li> <li><strong>Generation:</strong> The LLM generates an answer based on both its training and the new source.</li> </ol> <p><strong>Result:</strong> New Information + Known Source.</p> <div class="fake-img l-body"> <div class="mermaid"> graph LR A[User Prompt] --&gt; B(Search Vector DB); C[Documents] --&gt; B; B --&gt; D[Retrieved Context]; D --&gt; E(LLM Input); A --&gt; E; E --&gt; F[Answer with Source]; </div> <div class="caption"> RAG Workflow: Augmenting generation with retrieval. </div> </div> <hr/> <h2 id="iv-why-rag">IV. Why RAG?</h2> <p>The primary advantage is <strong>efficiency and cost</strong>.</p> <p>As new information arises (e.g., new product manuals, daily news), you do <strong>not</strong> have to retrain the LLM, which is computationally expensive and slow. You only need to update the <strong>Vector Database</strong>, which is cheap and instant.</p> <d-cite key="ibm_rag_2023"></d-cite>]]></content><author><name>Jongmin Mun</name></author><category term="generative-ai"/><category term="distill"/><category term="formatting"/><summary type="html"><![CDATA[Understanding RAG: Connecting frozen LLMs to external dynamic knowledge.]]></summary></entry><entry><title type="html">Prompting for Vibe Coding</title><link href="https://jong-min-moon.github.io/blog/2026/vibe-coding/" rel="alternate" type="text/html" title="Prompting for Vibe Coding"/><published>2026-02-15T00:00:00+00:00</published><updated>2026-02-15T00:00:00+00:00</updated><id>https://jong-min-moon.github.io/blog/2026/vibe-coding</id><content type="html" xml:base="https://jong-min-moon.github.io/blog/2026/vibe-coding/"><![CDATA[<h2 id="i-structure--preparation-details-up-front">I. Structure &amp; Preparation: Details Up Front</h2> <p>The most common mistake in AI-assisted coding (“Vibe Coding”) is diving straight into the IDE without a plan.</p> <p><strong>Before using Cursor or any coding agent:</strong></p> <ol> <li>Go to your favorite high-reasoning LLM (e.g., Claude 3.5 Sonnet, GPT-4o).</li> <li><strong>Chat back and forth</strong> to solidify your requirements.</li> <li>Ask it to <strong>write the first prompt</strong> for you, with clear specifications in titles and bullet points.</li> <li>Explicitly tell it: <em>“Build instructions that will be fed into Cursor.”</em></li> </ol> <p>This “pre-prompting” step ensures that the coding agent receives a structured, unambiguous blueprint rather than a vague intent.</p> <hr/> <h2 id="ii-iterative-building-the-constraints--donts">II. Iterative Building: The Constraints &amp; Don’ts</h2> <p>Building complex software with AI should be treated like a <strong>Coordinate Descent Algorithm</strong>: optimize one variable at a time while keeping others fixed.</p> <p>For each iteration, focus on improving <strong>one specific feature</strong> while explicitly constraining the agent to leave other parts untouched.</p> <p><strong>The Prompting Pattern:</strong></p> <ul> <li>“Only improve [Feature X]…”</li> <li>“Do <strong>not</strong> touch [Feature Y]…”</li> <li>“Make sure not to break [Existing Functionality Z]…”</li> </ul> <div class="fake-img l-body"> <div class="mermaid"> graph TD A[Start Iteration] --&gt; B{Choose Target Feature}; B --&gt; C[Fix All Other Variables]; C --&gt; D[Optimize Target]; D --&gt; E{Constraints Violated?}; E -- Yes --&gt; F[Revert &amp; Refine Constraints]; E -- No --&gt; G[Commit &amp; Next Iteration]; F --&gt; D; </div> <div class="caption"> The Coordinate Descent approach to AI coding. </div> </div> <hr/> <h2 id="iii-reverse-meta-prompting">III. Reverse Meta Prompting</h2> <p>Don’t just fix bugs; learn from them. <strong>Reverse Meta Prompting</strong> turns every error into an asset for future coding sessions.</p> <p><strong>The Workflow:</strong></p> <ol> <li><strong>Resolve the Issue:</strong> Work with the AI to fix a specific bug.</li> <li><strong>Summarize:</strong> Ask the AI: <em>“Summarize what went wrong and exactly how it was fixed.”</em></li> <li><strong>Generate Prompt:</strong> Ask natural follow-up: <em>“Generate a reusable prompt that I can use in the future to prevent or solve this specific challenge.”</em></li> <li><strong>Save:</strong> Store this prompt in your personal library.</li> </ol> <p>This creates a feedback loop where your “Vibe Coding” continually improves based on past experiences.</p> <hr/> <h2 id="iv-handling-persistent-errors">IV. Handling Persistent Errors</h2> <p>When the AI gets stuck in a loop or errors keep recurring, stop and switch strategies. Use this 4-step protocol:</p> <ol> <li><strong>Ask “What have you tried?”:</strong> Force the AI to list its failed attempts. This prevents it from looping through the same ineffective fixes.</li> <li><strong>Explain Simply:</strong> Re-explain the error in plain English. This provides fresh context and often helps align the AI’s understanding with the root cause.</li> <li><strong>Alternate Approach:</strong> Explicitly ask: <em>“Is there a completely different way to solve this?”</em></li> <li><strong>Revert and Replay:</strong> Rollbacks are your friend! It is often faster to revert to a clean state and try again than to untangle a messy, broken codebase.</li> </ol>]]></content><author><name>Jongmin Mun</name></author><category term="generative-ai"/><category term="distill"/><category term="formatting"/><summary type="html"><![CDATA[Strategies for effective AI-assisted coding: Structure, Iteration, and Meta-Prompting.]]></summary></entry><entry><title type="html">Dynamic Lot Sizing Problem</title><link href="https://jong-min-moon.github.io/blog/2026/dynamic-lot-sizing/" rel="alternate" type="text/html" title="Dynamic Lot Sizing Problem"/><published>2026-02-07T00:00:00+00:00</published><updated>2026-02-07T00:00:00+00:00</updated><id>https://jong-min-moon.github.io/blog/2026/dynamic-lot-sizing</id><content type="html" xml:base="https://jong-min-moon.github.io/blog/2026/dynamic-lot-sizing/"><![CDATA[<p>The <strong>Dynamic Lot Sizing Problem</strong> is a fundamental model in inventory management where a decision-maker must determine the optimal order quantities for a single item over a finite planning horizon.</p> <h2 id="problem-definition">Problem Definition</h2> <p>A manager decides how much inventory to order in each period $t$ to satisfy demand while minimizing total costs, which typically include ordering costs and holding costs.</p> <h3 id="key-assumptions">Key Assumptions</h3> <ol> <li><strong>Single-Item, Single-Level</strong>: We consider only the end product, ignoring raw materials or multi-echelon interactions.</li> <li><strong>Finite Planning Horizon</strong>: The decision-making process spans a discrete, finite timeline $t = 1, 2, \dots, T$.</li> <li><strong>Known Dynamic Demand</strong>: The demand $d_t$ for each period varies over time (hence “dynamic”) but is known in advance for the entire sequence $d_1, \dots, d_T$ (deterministic).</li> <li><strong>Periodic Review</strong>: Inventory levels are reviewed, and ordering decisions are made at the beginning of each period.</li> <li><strong>Unconstrained Capacity</strong>: There are no limits on the order quantity or inventory storage (infinite warehouse assumption).</li> <li><strong>No Backorders</strong>: Demand must be fully met in the period it occurs; shortages are not permitted.</li> </ol> <p>Input variables:</p> <ul> <li>$d_t$: demand in period $t$</li> <li>$c_o$: ordering cost</li> <li>$c_h$: holding cost</li> </ul> <h2 id="calcium-imaging">Calcium Imaging</h2> <p>given y_1, …, y_T, want to decide s_1, …, s_T and c_1,.. c_T c_t: current inventory level. s_t: order quantity in period t. perishable good: c_t = s_t + \gamma c_(t-1) the holding cost is 1/2(y_t-c_t)^2.</p>]]></content><author><name></name></author><category term="operations-research"/><category term="optimization"/><summary type="html"><![CDATA[An introduction to the Dynamic Lot Sizing Problem and its key assumptions.]]></summary></entry><entry><title type="html">Fundamentals of Diffusion Map Embedding</title><link href="https://jong-min-moon.github.io/blog/2024/diffusion-map-embedding/" rel="alternate" type="text/html" title="Fundamentals of Diffusion Map Embedding"/><published>2024-09-13T00:00:00+00:00</published><updated>2024-09-13T00:00:00+00:00</updated><id>https://jong-min-moon.github.io/blog/2024/diffusion-map-embedding</id><content type="html" xml:base="https://jong-min-moon.github.io/blog/2024/diffusion-map-embedding/"><![CDATA[<h2 id="the-diffusion-map-workflow">The Diffusion Map Workflow<d-cite key="KrishnaswamyLab2022Diffusion"></d-cite></h2> <p><strong>Input:</strong> Data in ambient dimension (of any type that a kernel can be defined).</p> <ol> <li><strong>Pairwise Distance Matrix:</strong> an $n \times n$ matrix, $(i,j)$-th entry is the distance between $X_i$ and $X_j$.</li> <li><strong>Affinity Matrix:</strong> Perform an entry-wise evaluation using a kernel function (typically Gaussian) to convert distances into affinities. Affinity captures the <strong>local geometric structure</strong> of the data and ignores the global structure.</li> <li><strong>Transition Matrix ($P$):</strong> Row-normalize the affinity matrix to create the stochastic transition matrix $P$, often referred to as the <strong>diffusion operator</strong>. This matrix defines the probability of a “random walk” jumping from one data point to another in a single step.</li> <li><strong>Spectral Decomposition:</strong> Perform an eigendecomposition on $P$. We focus on the non-trivial eigenvectors ${\psi_1, \psi_2, \dots, \psi_k}$ (excluding the constant $\psi_0$). The $i$-th entry of each eigenvector, scaled by its corresponding eigenvalue $\lambda^t$, serves as the new coordinate for the $i$-th data point.</li> </ol> <p><strong>Output:</strong> $k$-dimensional Euclidean vectors representing the data on the underlying manifold.</p> <h2 id="distance-matrix">Distance Matrix</h2> <p>For Euclidean data, the entries of the distance matrix are defined as: \(D(x_i, x_j) = \sqrt{\|x_i - x_j\|^2}\) However, the data can be of any type, provided a suitable kernel can be defined to measure similarity. In the distance matrix below, we observe a banded pattern extending across the entire matrix. indicating a global structure.</p> <div class="fake-img l-body"> <img src="/assets/img/diffusion-map-embedding/dme_distance.png" alt="distance matrix" width="90%" style="display: block; margin: auto;"/> <div class="caption"> Distance matrix </div> </div> <h2 id="affinity-matrix">Affinity Matrix</h2> <p>The pairwise distances are then passed through a nonlinear kernel function to calculate affinities. The nonlinearity effectively preserves local geometric information by giving higher weight to nearby points. For example, using a Gaussian kernel: \(A(x_i, x_j) = \exp\left(-\frac{D(x_i, x_j)^2}{\sigma}\right)\) In this context, $\sigma$ (or $\epsilon$) acts as a scale parameter that determines the size of the local neighborhood. There are many other kernels other than Gaussian kernel.</p> <p>The Affinity matrix below show that global structure is partially removed (points are arranged according to the underlying swiss roll structure). The graph shows that there still exists unncessary edges.</p> <p>div class=”fake-img l-body”&gt; <img src="/assets/img/diffusion-map-embedding/dme_affinity.png" alt="affinity matrix" width="90%" style="display: block; margin: auto;"/></p> <div class="caption"> Affinity matrix </div> <p>&lt;/div&gt;</p> <h2 id="transition-matrix">Transition Matrix</h2> <p>The affinity matrix is then row-normalized to create the stochastic transition matrix $P = D^{-1} A$, the affinity matrix pre-multiplied by the degree inverse matrix. This matrix defines the probability of a “random walk” jumping from one data point to another in a single step.</p> <p>This transition matrix $P$ acts as a Diffusion Operator with several key properties:</p> <ol> <li>Markov Chains: Diffusion operators define Markov Chains.</li> <li>Assymetric: Because the operator is not necessarily symmetric, right eigenvectors ($Pu = \lambda u$) are generally unequal to left eigenvectors ($uP = \lambda u$).</li> <li>Steady State: The left eigenvector corresponding to $\lambda = 1$ is the steady state vector. In Markov chain all the eigenvalues are less than or equal to 1.</li> <li>Triviality: The right eigenvector corresponding to $\lambda = 1$ is trivial unless the graph is disconnected.</li> <li>Powering: Powering a diffusion operator is mathematically equivalent to powering only its eigenvalues: \(P^t = U \Lambda^t U^{-1}\)</li> </ol> <h3 id="heat-transfer">Heat Transfer</h3> <p>Why is $P$ called a diffusion operator? Because it diffuses heat! Since $P$ is a $n \times n$ matrix, it is a linear operator mapping a vector $f \in \mathbb{R}^n$ onto another vector in $\mathbb{R}^n$.</p> <ul> <li>Input: $f$ is a vector of length $n$, where each entry represents the “heat” at a specific data point. For example, if you put “1” at point $A$ and “0” everywhere else, you are starting with all the heat at point $A$.</li> <li>Operation: When you multiply the matrix $P$ by your vector ($P f$), the matrix acts as the diffusion operator. According to the transition probabilities in $P$, the heat at point $i$ is redistributed to its neighbors. Points that have high affinity (local similarity) receive more heat than points that are far away.</li> <li>Output: The output is a new $n$-vector, $f_{next} = Pf$. Each entry in this new vector contains the “updated” heat levels. If you repeat this $t$ times ($P^t f$), you are simulating the diffusion process over a specific time scale.</li> </ul> <h2 id="eigendecomposition-and-embedding">Eigendecomposition and Embedding</h2> <p>At this stage, diffusion map embedding also does eigendecomposition, but on a $n \times n$ matrix, not a $p \times p$ matrix. We compare the process with PCA.</p> <h3 id="1-principal-component-analysis-pca">1. Principal Component Analysis (PCA)</h3> <p>PCA operates on the <strong>feature space</strong>. We first compute the covariance matrix $\Sigma = \frac{1}{n-1}X^TX$, which is a $p \times p$ matrix. We then perform the eigendecomposition: \(\Sigma = U \Lambda U^T\) We retain the first $k$ components to form $U_k$. The low-dimensional embedding is then calculated via <strong>projection</strong> (inner product): \(X_{low} = XU_k\) By design, this imbedding preserves the covariance matrix.</p> <h3 id="2-diffusion-map-embedding">2. Diffusion Map Embedding</h3> <p>In contrast, Diffusion Maps operate on the <strong>sample space</strong>. Here, we use a stochastic transition matrix $M$, which is $n \times n$ (where $n$ is the number of observations). Now each observation $X_i$ need not be $p$-dimensional Euclidean. It can be of any data type for which a kernel can be defined.</p> <p>The eigenvector of $M$ is therefore an $n$-vector. For embedding, we do not project, but lookup and scale.</p> <ul> <li>For each observation $x_i$, we extract the $i$-th element from the first $k$ eigenvectors.</li> <li>After scaling by the eigenvalues $\lambda^t$ to account for the diffusion time, we arrive at the $k$-dimensional embedding: \(\Psi_t(x_i) = \left( \lambda_1^t \psi_1(i), \lambda_2^t \psi_2(i), \dots, \lambda_k^t \psi_k(i) \right)\)</li> </ul>]]></content><author><name>Jongmin Mun</name></author><category term="research"/><category term="computational-neuroscience"/><category term="distill"/><category term="formatting"/><summary type="html"><![CDATA[Principles and practice of nonlinear dimensionality reduction popularly used in neuroscience.]]></summary></entry></feed>